{
        "lbi": {
        "prefix": "lbi",
        "body": [
            "int(lower_bound($a.begin(), $a.end(), $0) - $a.begin())",
        ]
    },
    "lb": {
        "prefix": "lb",
        "body": [
            "lower_bound($a.begin(), $a.end(), $0)",
        ]
    },
    "ubi": {
        "prefix": "ubi",
        "body": [
            "int(upper_bound($a.begin(), $a.end(), $0) - $a.begin())",
        ]
    },
    "ub": {
        "prefix": "ub",
        "body": [
            "lower_bound($a.begin(), $a.end(), $0)",
        ]
    },
    "cn": {
        "prefix": "cn",
        "body": [
            "cin >> ",
        ]
    },
    "cnv": {
        "prefix": "cnv",
        "body": [
            "for (int i = 0; i < (int) $v.size(); ++i) {",
            "    cin >> $v[i];",
            "}",
        ]
    },
    "co": {
        "prefix": "co",
        "body": [
            "cout << ",
        ]
    },
    "col": {
        "prefix": "col",
        "body": [
            "cout << $0 << '\\n';",
        ]
    },
    "cov": {
        "prefix": "cov",
        "body": [
            "for (int i = 0; i < int($v.size()); ++i) {",
            "    cout << $v[i] << \" \\n\"[i == int($v.size()) - 1];",
            "}",
        ]
    },  
    "coyesno": {
        "prefix": "coyes",
        "body": [
            "cout << \"yes\" << '\\n';",
        ]
    },
    "lam" : {
        "prefix": "lam",
        "body": [
            "auto $0 = [&]() -> void {",
            "};",
        ]
    },
    "el": {
        "prefix": "el", "body": ["'\\n'", ]
    },
    "db": {
        "prefix": "db", "body": ["double", ]
    },
    "ld": {
        "prefix": "ld", "body": [ "long double", ]
    },
    "ll": {
        "prefix": "ll", "body": ["int64_t", ]
    },
    "ull": {
        "prefix": "ull", "body": ["uint64_t", ]
    },
    "i128": {
        "prefix": "i128", "body": ["__int128", ]
    },
    "fa": {
        "prefix": "fa",
        "body": [
            "for (auto &$0 : ) {",
            "}",
        ]
    },
    "fai": {
        "prefix": "fai",
        "body": [
            "for (auto &i : ) {",
            "}",
        ]
    },
    "faj": {
        "prefix": "faj",
        "body": [
            "for (auto &j : ) {",
            "}",
        ]
    },
    "fak": {
        "prefix": "fak",
        "body": [
            "for (auto &k : ) {",
            "}",
        ]
    },
    "fat": {
        "prefix": "fat",
        "body": [
            "for (auto &[$0] : ) {",
            "}",
        ]
    },
    "fk": {
        "prefix": "fk",
        "body": [
            "for (int $1 = 0; $1 < $0; ++$1) {",
            "}",
        ]
    },
    "fkv": {
        "prefix": "fkv",
        "body": [
            "for (int i = 0; i < int($0.size()); ++i) {",
            "}",
        ]
    },
    "fki": {
        "prefix": "fki",
        "body": [
            "for (int i = 0; i < $0; ++i) {",
            "}",
        ]
    },
    "fkj": {
        "prefix": "fkj",
        "body": [
            "for (int j = 0; j < $0; ++j) {",
            "}",
        ]
    },
    "fkk": {
        "prefix": "fkk",
        "body": [
            "for (int k = 0; k < $0; ++k) {",
            "}",
        ]
    },
    "fb": {
        "prefix": "fb",
        "body": [
            "for (int $1 = 1; $1 <= $0; ++$1) {",
            "}",
        ]
    },
    "fbi": {
        "prefix": "fbi",
        "body": [
            "for (int i = 1; i <= $0; ++i) {",
            "}",
        ]
    },
    "fbj": {
        "prefix": "fbj",
        "body": [
            "for (int j = 1; j <= $0; ++j) {",
            "}",
        ]
    },
    "fbk": {
        "prefix": "fbk",
        "body": [
            "for (int k = 1; k <= $0; ++k) {",
            "}",
        ]
    },
    "fni": {
        "prefix": "fni",
        "body": [
            "for (int i = n - 1; i >= 0; --i) {",
            "}",
        ]
    },
    "fnj": {
        "prefix": "fnj",
        "body": [
            "for (int j = n - 1; j >= 0; --j) {",
            "}",
        ]
    },
    "fnk": {
        "prefix": "fnk",
        "body": [
            "for (int k = n - 1; k >= 0; --k) {",
            "}",
        ]
    },
    "mii": {
        "prefix": "mii",
        "body": [
            "map<int, int>",
        ]
    },
    "mll": {
        "prefix": "mll",
        "body": [
            "map<int64_t, int64_t>",
        ]
    },
    "V": {
        "prefix": "V",
        "body": [
            "vector<$0>",
        ]
    },
    "VV": {
        "prefix": "VV",
        "body": [
            "vector<vector<$0>>",
        ]
    },
    "VVV": {
        "prefix": "VVV",
        "body": [
            "vector<vector<vector<$0>>>",
        ]
    },
    "VVVV": {
        "prefix": "VVVV",
        "body": [
            "vector<vector<vector<vector<$0>>>>",
        ]
    },
    "vi": {
        "prefix": "vi",
        "body": [
            "vector<int>",
        ]
    },
    "vl": {
        "prefix": "vl",
        "body": [
            "vector<int64_t>",
        ]
    },
    "vpii": {
        "prefix": "vpii",
        "body": [
            "vector<pair<int, int>>",
        ]
    },
    "vpll": {
        "prefix": "vpll",
        "body": [
            "vector<pair<int64_t, int64_t>>",
        ]
    },
    "vvi": {
        "prefix": "vvi",
        "body": [
            "vector<vector<int>>$0",
        ]
    },
    "vvl": {
        "prefix": "vvl",
        "body": [
            "vector<vector<int64_t>>$0",
        ]
    },
    "vvv": {
        "prefix": "vvv",
        "body": [
            "vector<vector<vector<$0>>>",
        ]
    },
    "vvvi": {
        "prefix": "vvvi",
        "body": [
            "vector<vector<vector<int>>>$0",
        ]
    },
    "vvvl": {
        "prefix": "vvvl",
        "body": [
            "vector<vector<vector<int64_t>>>$0",
        ]
    },
    "pii": {
        "prefix": "pii",
        "body": [
            "pair<int, int>",
        ]
    },
    "pll": {
        "prefix": "pll",
        "body": [
            "pair<int64_t, int64_t>",
        ]
    },
    "spii": {
        "prefix": "pii",
        "body": [
            "set<pair<int, int>>",
        ]
    },
    "spll": {
        "prefix": "pll",
        "body": [
            "set<pair<int64_t, int64_t>>",
        ]
    },
    "so": {
        "prefix": "so",
        "body": [
            "sort($1.begin(), $1.end());$0",
        ]
    },
    "rso": {
        "prefix": "so",
        "body": [
            "sort($1.rbegin(), $1.rend());$0",
        ]
    },
    "sol": {
        "prefix": "sol",
        "body": [
            "sort($1.begin(), $1.end(), [&](auto& g, auto& h) {$0",
            "});",
        ]
    },
    "pb": {
        "prefix": "pb",
        "body": [
            "push_back($0)",
        ]
    },
    "sr": {
        "prefix": "sr",
        "body": [
            "string",
        ]
    },
    "sz": {
        "prefix": "sz",
        "body": [
            "int($v.size())$0",
        ]
    },
    "all": {
        "prefix": "all",
        "body": [
            "$v.begin(), $v.end()$0",
        ]
    },
    "rall": {
        "prefix": "rall",
        "body": [
            "$v.rbegin(), $v.rend()$0",
        ]
    },
    "bg": {
        "prefix": "bg",
        "body": [
            "$v.begin()$0",
        ],
        "description": ".begin()"
    },
    "ed": {
        "prefix": "ed",
        "body": [
            "$v.end()$0",
        ],
        "description": ".end()"
    },
    "rv": {
        "prefix": "rv",
        "body": [
            "reverse($v.begin(), $v.end())$0",
        ],
    },
    "uni": {
        "prefix": "uni",
        "body": [
            "sort($v.begin(), $v.end()), $v.erase(unique($v.begin(), $v.end()), $v.end());$0"
        ]
    },
    "nummin": {
        "prefix": "nummin",
        "body": [
            "*min_element($V.begin(), $V.end())$0"
        ]
    },
    "nummax": {
        "prefix": "nummax",
        "body": [
            "*max_element($V.begin(), $V.end())$0"
        ]
    },
    "numpsum": {
        "prefix": "numpsum",
        "body": [
            "auto $prefixsum = $0;",
            "for (auto i = 1; i < int($prefixsum.size()); ++i) {",
            "    $prefixsum[i] += $prefixsum[i - 1];",
            "}",
            "auto query = [&](int l, int r) { // [l, r)",
            "    auto sma = (l > 0) ? $prefixsum[l - 1] : 0;",
            "    return 0ll + $prefixsum[r - 1] - sma;",
            "};",
        ]
    },
    "numsum": {
        "prefix": "numsum",
        "body": [
            "accumulate($X.begin(), $X.end(), 0);$0"
        ]
    },
    "ckmn": {
        "prefix": "ckmn",
        "body": [
            "template<typename A, typename B>",
            "bool ckmn(A &x, const B &y) { return x > y && (x = y, true); }"
        ]
    },
    "ckmx": {
        "prefix": "ckmx",
        "body": [
            "template<typename A, typename B>",
            "bool ckmx(A &x, const B &y) { return x < y && (x = y, true); }"
        ]
    },
    "atc": {
        "prefix": "atc",
        "body": [
            "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n    #include <other/debug.h>\n#else\n    #define debug(...) 0\n#endif\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    return 0;\n}"
        ],
        "description": "atc.cpp snippet"
    },
    "cao": {
        "prefix": "cao",
        "body": [
            "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n#    include <other/debug.h>\n#else\n#    define debug(...) 0\n#endif\nusing namespace std;\ntemplate <typename A, typename B>\nistream &operator>>(istream &in, pair<A, B> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\ntemplate <typename A, typename B>\nostream &operator<<(ostream &out, const pair<A, B> &p) {\n    out << p.first << ' ' << p.second;\n    return out;\n}\ntemplate <typename T>\nconcept ListOrVector = is_same_v<T, list<typename T::value_type>> or is_same_v<T, vector<typename T::value_type>>;\ntemplate <ListOrVector T>\nistream &operator>>(istream &in, T &p) {\n    for (auto &i : p) {\n        in >> i;\n    }\n    return in;\n}\ntemplate <ListOrVector T>\nostream &operator<<(ostream &os, const T &container) {\n    for (auto it = begin(container); it != end(container); ++it) {\n        if (it != begin(container)) {\n            os << ' ';\n        }\n        os << *it;\n    }\n    return os;\n}\ntemplate <typename A, typename B>\nbool ckmn(A &x, const B &y) {\n    return x > y && (x = y, true);\n}\ntemplate <typename A, typename B>\nbool ckmx(A &x, const B &y) {\n    return x < y && (x = y, true);\n}\ntemplate <typename T, typename U>\nT sum(const vector<U> &A) {\n    T sum = 0;\n    for (auto &&a : A) sum += a;\n    return sum;\n}\ntemplate <typename T, typename U>\nvector<T> presum(const vector<U> &A, int save0 = 0) {\n    size_t N = A.size();\n    vector<T> B(N + 1);\n    for (size_t i = 0; i < N; ++i) {\n        B[i + 1] = B[i] + A[i];\n    }\n    if (save0 == 0) {\n        B.erase(B.begin());\n    }\n    return B;\n}\ntemplate <typename T>\nvector<int> index_sort(const vector<T> &A) {\n    // stable index sort\n    vector<int> ids(A.size());\n    iota(ids.begin(), ids.end(), 0);\n    sort(ids.begin(), ids.end(), [&](int i, int j) {\n        if (A[i] == A[j]) {\n            return i < j;\n        } else {\n            return A[i] < A[j];\n        }\n    });\n    return ids;\n}\ntemplate <typename F>\nint64_t binary_search(F check, int64_t ok, int64_t ng, bool check_ok = true) {\n    // F(ok) = 1, F(ng) = 0\n    if (check_ok) {\n        assert(check(ok));\n        assert(!check(ng));\n    }\n    while (abs(ok - ng) > 1) {\n        auto x = (ng + ok) / 2;\n        tie(ok, ng) = (check(x) ? make_pair(x, ng) : make_pair(ok, x));\n    }\n    return ok;\n}\ntemplate <typename F>\ndouble binary_search(F check, double ok, double ng, int iter = 100) {\n    while (iter--) {\n        double x = (ok + ng) / 2;\n        tie(ok, ng) = (check(x) ? make_pair(x, ng) : make_pair(ok, x));\n    }\n    return (ok + ng) / 2;\n}\ntemplate <typename T, typename U>\nT ceil(T x, U y) {\n    return (x > 0 ? (x + y - 1) / y : x / y);\n}\ntemplate <typename T, typename U>\nT floor(T x, U y) {\n    return (x > 0 ? x / y : (x - y + 1) / y);\n}\ntemplate <typename t, typename u>\npair<t, t> div(t x, u y) {\n    t q = floor(x, y);\n    return {q, x - q * y};\n}\nint topbit(uint64_t x) {\n    return (x == 0 ? -1 : 63 - countl_zero(x));\n}\nint lowbit(uint64_t x) {\n    return (x == 0 ? -1 : countr_zero(x));\n}\nint popcount(int64_t x) {\n    return popcount((uint64_t) x);\n}\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T>\nusing VV = V<V<T>>;\ntemplate <typename T>\nusing VVV = V<VV<T>>;\ntemplate <typename T>\nusing VVVV = V<VVV<T>>;\ntemplate <typename T>\nusing dd = priority_queue<T, V<T>, less<T>>;\ntemplate <typename T>\nusing xd = priority_queue<T, V<T>, greater<T>>;\nusing sr = string;\nusing db = double;\nusing ld = long double;\nusing ll = long long;\nusing ull = unsigned long long;\nusing si = set<int>;\nusing sl = set<ll>;\nusing mii = map<int, int>;\nusing mll = map<ll, ll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing spii = set<pii>;\nusing spll = set<pll>;\nusing vpii = V<pii>;\nusing vpll = V<pll>;\nusing vvpii = VV<pii>;\nusing vvpll = VV<pll>;\nusing vi = V<int>;\nusing vvi = VV<int>;\nusing vvvi = VVV<int>;\nusing vl = V<ll>;\nusing vvl = VV<ll>;\nusing vvvl = VVV<ll>;\n// clang-format off\n#define OVERLOAD5(a, b, c, d, e, ...) e\n#define FOR4(i, a, b, c) for (auto i = (a); i < (b); i += (c))\n#define FOR1(a) FOR4(_, 0, a, 1)\n#define FOR2(i, a) FOR4(i, 0, a, 1)\n#define FOR3(i, a, b) FOR4(i, a, b, 1)\n#define fk(...) OVERLOAD5(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)  // fk\n#define FB4(i, a, b, c) for (auto i = (a); i <= (b); i += (c))\n#define FB1(a) FB4(_, 1, a, 1)\n#define FB2(i, a) FB4(i, 1, a, 1)\n#define FB3(i, a, b) FB4(i, a, b, 1)\n#define fb(...) OVERLOAD5(__VA_ARGS__, FB4, FB3, FB2, FB1)(__VA_ARGS__)  // fb\n#define FAN4(i, a, b, c) for (auto i = (a); i >= (b); i -= (c))\n#define FAN1(a) FAN4(_, a, 0, 1)\n#define FAN2(i, a) FAN4(i, a, 0, 1)\n#define FAN3(i, a, b) FAN4(i, a, b, 1)\n#define fn(...) OVERLOAD5(__VA_ARGS__, FAN4, FAN3, FAN2, FAN1)(__VA_ARGS__)  // fn\n#define OVERLOAD8(_1, _2, _3, _4, _5, _6, _7, _8, ...) _8\n#define EACHA2(a, b, v) a, b\n#define EACHA3(a, ...) a, EACHA2(__VA_ARGS__)\n#define EACHA4(a, ...) a, EACHA3(__VA_ARGS__)\n#define EACHA5(a, ...) a, EACHA4(__VA_ARGS__)\n#define EACHZ1(a, v) a\n#define EACHZ2(a, b, v) [EACHA2(a, b, v)]\n#define EACHZ3(a, ...) [ a, EACHA2(__VA_ARGS__) ]\n#define EACHZ4(a, ...) [ a, EACHA3(__VA_ARGS__) ]\n#define EACHZ5(a, ...) [ a, EACHA4(__VA_ARGS__) ]\n#define EACHZ6(a, ...) [ a, EACHA5(__VA_ARGS__) ]\n#define EACHB1(a, v) v\n#define EACHB2(a, ...) EACHB1(__VA_ARGS__)\n#define EACHB3(a, ...) EACHB2(__VA_ARGS__)\n#define EACHB4(a, ...) EACHB3(__VA_ARGS__)\n#define EACHB5(a, ...) EACHB4(__VA_ARGS__)\n#define EACHB6(a, ...) EACHB5(__VA_ARGS__)\n#define EACHA(...) OVERLOAD8(__VA_ARGS__, EACHZ6, EACHZ5, EACHZ4, EACHZ3, EACHZ2, EACHZ1)(__VA_ARGS__)\n#define EACHB(...) OVERLOAD8(__VA_ARGS__, EACHB6, EACHB5, EACHB4, EACHB3, EACHB2, EACHB1)(__VA_ARGS__)\n#define eh(...) for (auto &&EACHA(__VA_ARGS__) : EACHB(__VA_ARGS__))\n#define OVERLOAD7(a, b, c, d, e, f, g, ...) g\n#define PR1(a) ::std::cout << (a)\n#define PR2(a, ...) PR1(a); PR1(' '); PR1(__VA_ARGS__)\n#define PR3(a, ...) PR1(a); PR1(' '); PR2(__VA_ARGS__)\n#define PR4(a, ...) PR1(a); PR1(' '); PR3(__VA_ARGS__)\n#define PR5(a, ...) PR1(a); PR1(' '); PR4(__VA_ARGS__)\n#define PR6(a, ...) PR1(a); PR1(' '); PR5(__VA_ARGS__)\n#define print(...) OVERLOAD7(__VA_ARGS__, PR6, PR5, PR4, PR3, PR2, PR1)(__VA_ARGS__)  // print\n#define println(...) print(__VA_ARGS__); PR1('\\\\n')  // print '\\\\n'\n#define printe(...) print(__VA_ARGS__); PR1(::std::endl)  // print endl\n#define sz(x) ((int) x.size())\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define ft front\n#define bk back\n#define in insert\n#define pb push_back\n#define eb emplace_back\n#define em emplace\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\n#define fif first.first\n#define fis first.second\n#define sef second.first\n#define ses second.second\n#define so(x) sort(all(x))\n#define rso(x) sort(rall(x))\n#define rev(x) reverse(all(x))\n#define uni(x) sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit()\n#define ii(...) [](auto &..._x_) { (cin >> ... >> _x_); }(__VA_ARGS__)\n#define jj(...) __VA_ARGS__; ii(__VA_ARGS__)\n#define mine(v) (*min_element(v.begin(), v.end()))\n#define maxe(v) (*max_element(v.begin(), v.end()))\n#define gv1(n0, val) vector(n0, val)\n#define gv2(n0, ...) vector(n0, gv1(__VA_ARGS__))\n#define gv3(n0, ...) vector(n0, gv2(__VA_ARGS__))\n#define gv4(n0, ...) vector(n0, gv3(__VA_ARGS__))\n#define gv5(n0, ...) vector(n0, gv4(__VA_ARGS__))\n#define gv6(n0, ...) vector(n0, gv5(__VA_ARGS__))\n#define GET_GENV(_1, _2, _3, _4, _5, _6, _7, NAME, ...) NAME\n#define genv(...) GET_GENV(__VA_ARGS__, gv6, gv5, gv4, gv3, gv2, gv1)(__VA_ARGS__)  // gen vector\n#define fors(t, s) for (auto t = (s); t >= 0; t = (t == 0 ? -1 : (t - 1) & (s)))  // for_subset\n// clang-format on\nvoid solve() {\n    \n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        solve();\n    }\n    return 0;\n}\n"
        ],
        "description": "cao.cpp snippet"
    },
    "cf": {
        "prefix": "cf",
        "body": [
            "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n    #include <other/debug.h>\n#else\n    #define debug(...) 0\n#endif\nusing namespace std;\nvoid solve() {\n    \n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--) {\n        solve();\n    }\n    return 0;\n}"
        ],
        "description": "cf.cpp snippet"
    },
    "ds_cartesian_tree": {
        "prefix": "ds_cartesian_tree",
        "body": [
            "template <typename F = less<int>>\nclass Cartesian_tree {\n    int root = -1;\n    vector<int> lson, rson, father;\n    void build(vector<int> a) {\n        int n = (int) a.size();\n        lson = rson = father = vector<int>(n, -1);\n        stack<int, vector<int>> st;\n        for (int i = 0; i < n; ++i) {\n            int last = -1;\n            while (!st.empty() && !F()(a[st.top()], a[i])) {\n                last = st.top();\n                st.pop();\n            }\n            if (!st.empty()) {\n                rson[st.top()] = i;\n                father[i] = st.top();\n            } else {\n                root = i;\n            }\n            lson[i] = last;\n            if (last != -1) {\n                father[last] = i;\n            }\n            st.push(i);\n        }\n    }\n};"
        ],
        "description": "ds -> cartesian_tree.cpp snippet"
    },
    "ds_continuous_segs": {
        "prefix": "ds_continuous_segs",
        "body": [
            "template <typename T = int, typename seg_type = pair<T, T>>\nstruct Segs { // 维护连续区间\n    static const T inf = (int) 1e9 + 5;\n    // static const T inf = (T) 1e18 + 5;\n    static bool is_intersect(T l1, T r1, T l2, T r2) { // 相交\n        return !(l2 > r1 or r2 < l1);\n    }\n    static bool is_share_side(T l1, T r1, T l2, T r2) { // 相邻\n        return l2 == r1 + 1 or r2 == l1 - 1;\n    }\n    static bool is_is(T l1, T r1, T l2, T r2) {\n        return is_intersect(l1, r1, l2, r2) or is_share_side(l1, r1, l2, r2);\n    }\n    using seg_iterator = typename set<seg_type>::iterator;\n    set<seg_type> segs;\n    void add(T l, T r) { // 闭区间\n        auto it = find_isis(l, r);\n        while (it != segs.end()) {\n            T x = it->first, y = it->second;\n            if (is_is(x, y, l, r)) {\n                l = min(l, x), r = max(r, y);\n                ++it;\n                segs.erase({x, y});\n            } else {\n                break;\n            }\n        }\n        segs.emplace(l, r);\n    }\n    void remove(T l, T r) { // 闭区间\n        auto insert = [&](T l, T r) {\n            if (r >= l) {\n                segs.emplace(l, r);\n            }\n        };\n        auto split = [&](T p) -> void {\n            auto it = find(p);\n            if (it != segs.end()) {\n                T x = it->first, y = it->second;\n                segs.erase(it);\n                insert(x, p - 1);\n                insert(p, p);\n                insert(p + 1, y);\n            }\n        };\n        split(l);\n        split(r);\n        auto it = segs.lower_bound({l, l});\n        while (it != segs.end()) {\n            auto [x, y] = *it;\n            if (x > r) {\n                break;\n            } else {\n                ++it;\n                segs.erase({x, y});\n            }\n        }\n    }\n    seg_iterator find(T p) { // 返回与点p有交集的iterator(显然这样的iterator个数<=1)\n        auto it = segs.upper_bound({p, inf});\n        if (it != segs.begin()) {\n            --it;\n            auto [x, y] = *it;\n            if (y >= p) {\n                return it;\n            }\n        }\n        return segs.end();\n    }\n    seg_iterator find(T l, T r) { // 返回与[l, r]有交集的最左侧的的iterator\n        auto re = find(l);\n        if (re != segs.end()) { // 与左端点有交集的区间\n            return re;\n        } else {\n            auto it = segs.upper_bound({l, l});\n            if (it != segs.end() && it->first <= r) {\n                return it;\n            } else {\n                return segs.end();\n            }\n        }\n    }\n    seg_iterator find_isis(T l, T r) { // 最左侧的满足isis的iterator\n        auto re = segs.end();\n        auto it = segs.lower_bound({l, l});\n        while (true) {\n            if (it != segs.end()) {\n                T x = it->first, y = it->second;\n                if (is_is(x, y, l, r)) {\n                    re = it;\n                } else if (y < l - 1) {\n                    break;\n                }\n            }\n            if (it == segs.begin()) {\n                break;\n            }\n            --it;\n        }\n        return re;\n    }\n\n};"
        ],
        "description": "ds -> continuous_segs.cpp snippet"
    },
    "ds_custom_hash": {
        "prefix": "ds_custom_hash",
        "body": [
            "struct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\n// unordered_map<long long, int, custom_hash> safe_map;\n// gp_hash_table<long long, int, custom_hash> safe_hash_table;"
        ],
        "description": "ds -> custom_hash.cpp snippet"
    },
    "ds_custom_list": {
        "prefix": "ds_custom_list",
        "body": [
            "template <typename T>\nstruct custom_list {\n    struct Node {\n        T val;\n        Node *prev, *next;\n        Node() : val(), prev(nullptr), next(nullptr) {}\n        Node(const T &val) : val(val), prev(nullptr), next(nullptr) {}\n    };\n    Node *head, *tail;\n    size_t sz;\n    custom_list() : head(new Node()), tail(new Node()), sz(0) {\n        head->next = tail;\n        tail->prev = head;\n    }\n    ~custom_list() {\n        while (head != nullptr) {\n            Node *tmp = head;\n            head = head->next;\n            delete tmp;\n        }\n    }\n    Node *push_back(const T &val) {\n        Node *node = new Node(val);\n        node->prev = tail->prev;\n        node->next = tail;\n        tail->prev->next = node;\n        tail->prev = node;\n        ++sz;\n        return node;\n    }\n    Node *push_front(const T &val) {\n        Node *node = new Node(val);\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n        ++sz;\n        return node;\n    }\n    Node *begin() const {\n        return head->next;\n    }\n    Node *end() const {\n        return tail;\n    }\n    void pop_back() {\n        if (sz == 0) {\n            return;\n        }\n        Node *node = tail->prev;\n        tail->prev = node->prev;\n        node->prev->next = tail;\n        delete node;\n        --sz;\n    }\n    void pop_front() {\n        if (sz == 0) {\n            return;\n        }\n        Node *node = head->next;\n        head->next = node->next;\n        node->next->prev = head;\n        delete node;\n        --sz;\n    }\n    T &front() {\n        return head->next->val;\n    }\n    T &back() {\n        return tail->prev->val;\n    }\n    size_t size() {\n        return sz;\n    }\n};"
        ],
        "description": "ds -> custom_list.cpp snippet"
    },
    "ds_fenwick": {
        "prefix": "ds_fenwick",
        "body": [
            "template <typename T>\nstruct fenwick {\n    vector<T> a;\n    void init(int n) { // [0, n)\n        assert(n >= 1);\n        a = vector<T>(n + 1, 0);\n    }\n    void update(int p, T delta) { // p in [0, n)\n        p += 1;\n        for (; p < (int) a.size(); p += p & (-p)) {\n            a[p] += delta;\n        }\n    } \n    T query(int p) { // [0, p)\n        if (p < 0) {\n            return 0;\n        }\n        T res = 0;\n        for (; p; p -= p & -p) {\n            res += a[p];\n        }\n        return res;\n    }\n    void set(int p, T x) { // single point\n        update(p, x - get(p));\n    }\n    T get(int p) { // single point\n        return query(p + 1) - query(p);\n    }\n    int max_length(T s) { // max length of a[0] + a[1] + ... <= s\n        int pos = 0;\n        int topbit = 31 - __builtin_clz(a.size() - 1);\n        for (int j = topbit; j >= 0; j--) {\n            if (pos + (1 << j) < (int) a.size() && a[pos + (1 << j)] <= s) {\n                pos += (1 << j);\n                s -= a[pos];\n            }\n        }\n        return pos;\n    }\n};\n"
        ],
        "description": "ds -> fenwick.cpp snippet"
    },
    "ds_fenwick_2d": {
        "prefix": "ds_fenwick_2d",
        "body": [
            "template <typename T>\nclass FenwickTree2D {\n   public:\n    vector<vector<T>> fenw;\n    int n, m;\n\n    FenwickTree2D() : n(0), m(0) {}\n    FenwickTree2D(int n_, int m_) : n(n_), m(m_) {\n        fenw.resize(n);\n        for (int i = 0; i < n; i++) {\n            fenw[i].resize(m);\n        }\n    }\n\n    void Modify(int i, int j, T v) {\n        assert(0 <= i && i < n && 0 <= j && j < m);\n        int x = i;\n        while (x < n) {\n            int y = j;\n            while (y < m) {\n                fenw[x][y] += v;\n                y |= y + 1;\n            }\n            x |= x + 1;\n        }\n    }\n\n    T Query(int i, int j) {\n        assert(0 <= i && i <= n && 0 <= j && j <= m);\n        T v{};\n        int x = i;\n        while (x > 0) {\n            int y = j;\n            while (y > 0) {\n                v += fenw[x - 1][y - 1];\n                y &= y - 1;\n            }\n            x &= x - 1;\n        }\n        return v;\n    }\n};"
        ],
        "description": "ds -> fenwick_2d.cpp snippet"
    },
    "ds_fenwick_bit": {
        "prefix": "ds_fenwick_bit",
        "body": [
            "template <typename T>\nclass FenwickTree {\n    public:\n    vector<T> fenw;\n    int n;\n    int pw;\n\n    FenwickTree() : n(0) {}\n    FenwickTree(int n_) : n(n_) {\n        fenw.resize(n);\n        pw = bit_floor(unsigned(n));\n    }\n\n    void Modify(int x, T v) {\n        assert(0 <= x && x < n);\n        while (x < n) {\n            fenw[x] += v;\n            x |= x + 1;\n        }\n    }\n\n    // query [0, x)\n    T Query(int x) {\n        assert(0 <= x && x <= n);\n        T v = 0;\n        while (x > 0) {\n            v += fenw[x - 1];\n            x &= x - 1;\n        }\n        return v;\n    }\n\n    // Returns the length of the longest prefix with sum <= c\n    // the length! the length! the length! \n    int MaxPrefix(T c) {\n        T v = 0;\n        int at = 0;\n        for (int len = pw; len > 0; len >>= 1) {\n            if (at + len <= n) {\n                auto nv = v;\n                nv += fenw[at + len - 1];\n                if (!(c < nv)) {\n                    v = nv;\n                    at += len;\n                }\n            }\n        }\n        assert(0 <= at && at <= n);\n        return at;\n    }\n};\n"
        ],
        "description": "ds -> fenwick_bit.cpp snippet"
    },
    "ds_fenwick_nest": {
        "prefix": "ds_fenwick_nest",
        "body": [
            "template <typename T>\nstruct fenwick {\n    vector<T> a;\n    void init(int n) {  // [0, n)\n        assert(n >= 1);\n        a = vector<T>(n + 1, 0);\n    }\n    void update(int p, T delta) {  // p in [0, n)\n        p += 1;\n        for (; p < (int)a.size(); p += p & (-p)) {\n            a[p] += delta;\n        }\n    }\n    T query(int p) {  // [0, p)\n        if (p < 0) {\n            return 0;\n        }\n        T res = 0;\n        for (; p; p -= p & -p) {\n            res += a[p];\n        }\n        return res;\n    }\n};\ntemplate <typename T>\nstruct fenwick_nest {\n    fenwick<T> d, id;\n    void init(int n) {\n        d.init(n);\n        id.init(n);\n    }\n    void update(int l, int r, T x) {  // update: [l, r)\n        d.update(l, x);\n        id.update(l, x * l);\n        if (r < (int)d.a.size()) {\n            d.update(r, -x);\n            id.update(r, r * -x);\n        }\n    }\n    T query(int l, int r) {  // query on [l, r)\n        T sm1 = l * d.query(l) - id.query(l);\n        T sm2 = r * d.query(r) - id.query(r);\n        return sm2 - sm1;\n    }\n};\nvoid test_Fenwick2() {\n    const int n = 10;\n    const int T = 10000;\n    mt19937 mt(std::random_device{}());\n    fenwick_nest<long long> fenwickTree;\n    fenwickTree.init(n);\n    vector<long long> arr(n, 0);\n    auto mtrand = [&](int l, int r) {\n        std::uniform_int_distribution<> uid(l, r - 1);\n        return uid(mt);\n    };\n    for (int t = 0; t < T; t++) {\n        int l = mtrand(0, n);\n        int r = mtrand(0, n);\n        if (l > r) {\n            swap(l, r);\n        }\n        ++r;\n        if (mtrand(0, 2) % 2) {\n            long long value = mtrand(0, 2000) - 1000;\n            fenwickTree.update(l, r, value);\n            for (int i = l; i < r; ++i) {\n                arr[i] += value;\n            }\n        } else {\n            long long simpleArraySum = 0;\n            for (int i = l; i < r; i++) {\n                simpleArraySum += arr[i];\n            }\n            assert(fenwickTree.query(l, r) == simpleArraySum);\n        }\n    }\n    cout << \"All tests passed!\" << endl;\n}"
        ],
        "description": "ds -> fenwick_nest.cpp snippet"
    },
    "ds_pbds_hash": {
        "prefix": "ds_pbds_hash",
        "body": [
            "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\nusing namespace std;\n__gnu_pbds::gp_hash_table<string, int>::iterator it; //是的你没看错，这个hash表有迭代器！但是我并不知道这有什么用\n__gnu_pbds::gp_hash_table<string, int> h; // string -> int\nstring hh;\nint n, a, m;\nint main()\n{\n    h[\"lskjdf\"] = 123; //可以像 map 一样直接访问元素\n    it = h.begin();//是的你没看错，这个hash表有迭代器！但是我并不知道这有什么用\n    for (int ww = 1; ww <= m; ww++)\n    {\n        cin >> hh;\n        //若哈希表中不存在查找的元素，.find() 会返回 .end()\n        if (h.find(hh) != h.end()) //如果找的到这个元素\n        {\n            cout << h.find(hh)->first << \" \" << h.find(hh)->second << endl;\n            //first对应的是Key , second 对应的是 Value\n            //hash_.erase(hh);  删掉 hh 这里不做演示\n        }\n        else\n        {\n            cout << \"No found!\\\\n\";\n        }\n    }\n    return 0;\n}\n"
        ],
        "description": "ds -> pbds_hash.cpp snippet"
    },
    "ds_pbds_tree": {
        "prefix": "ds_pbds_tree",
        "body": [
            "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\n__gnu_pbds::tree< \n    std::string, // key值\n    __gnu_pbds::null_type, /* 这是映射到的值，我们现在不需要，所以填null_type */\n    std::less<std::string>, /* 比较规则，可以使用仿函数的形式 */\n    __gnu_pbds::rb_tree_tag, /* 树的类型 红黑树一般为最优 */\n    __gnu_pbds::tree_order_statistics_node_update /* 节点更新类型 */\n    > k;\n\nint main() {\n    int cnt = 0;\n    k.insert(\"man\");\n    k.insert(\"what\");\n    k.insert(\"can\");\n    k.insert(\"i\");\n    k.insert(\"say\");\n    // after inserts: {\"can\",\"i\",\"man\",\"say\",\"what\"}\n    auto it = k.find(\"can\");\n    cout << *it << endl; \n\n    it = k.find_by_order(0); // find by rank\n    cout << *it << endl; // can\n\n    it = k.find_by_order(1);\n    cout << *it << endl; // i\n    it = k.find_by_order(2);\n    cout << *it << endl; // man\n\n    int f = k.order_of_key(\"man\"); // find by key\n    cout << f << endl;\n\n    for (auto kk = k.begin(); kk != k.end(); kk++) {\n        cout << (*kk) << \" \"; // can i man say what\n    } \n    return 0;\n}"
        ],
        "description": "ds -> pbds_tree.cpp snippet"
    },
    "ds_rmq_disjoint": {
        "prefix": "ds_rmq_disjoint",
        "body": [
            "/*\n    mat[0] 就是原数组\n    mat[p] 是逐长度为2**p的段进行分割，每段都从中心开始向左/右求后/前缀和\n    例如p = 1, 2**p = 2\n    分段为[0, 4), [4, 8), [8, 16), [16, 32), [32, 64)\n    每段的中心为2, 2 + 4, 2 + 4 + 4, ...\n\n    查询时, 如果\n    l = 1101​[0​]01\n    r = 1101​[1​]10\n    l和r在最大的4层中位于相同的段中\n    在mat[2]中，二者位于某一段中的中心的两侧\n*/\ntemplate <typename T, typename F>\nclass DisjointSparseTable {\n   public:\n    int n;\n    vector<vector<T>> mat;\n    F func;\n\n    DisjointSparseTable(const vector<T>& a, const F& f) : n(int(a.size())), func(f) {\n        mat.push_back(a);\n        for (int p = 1; (1 << p) < n; p++) {\n            mat.emplace_back(n);\n            for (int mid = 1 << p; mid < n; mid += 1 << (p + 1)) {\n                mat[p][mid - 1] = a[mid - 1];\n                for (int j = mid - 2; j >= mid - (1 << p); j--) {\n                    mat[p][j] = func(a[j], mat[p][j + 1]);\n                }\n                mat[p][mid] = a[mid];\n                for (int j = mid + 1; j < min(n, mid + (1 << p)); j++) {\n                    mat[p][j] = func(mat[p][j - 1], a[j]);\n                }\n            }\n        }\n    }\n\n    T Query(int l, int r) const {\n        assert(0 <= l && l < r && r <= n);\n        if (r - l == 1) {\n            return mat[0][l];\n        }\n        // bit_width = topbit所在位置，等价于32(64) - __builtin_clz(ll)\n        int p = bit_width(unsigned(l ^ (r - 1))) - 1;\n        return func(mat[p][l], mat[p][r - 1]);\n    }\n};\n\n// DisjointSparseTable<int, greater<int>> ra(a, greater<int>()); // 错误\n// DisjointSparseTable ra(a, std::function(std::gcd<int, int>));\n// DisjointSparseTable ra(a, [&](int x, int y) { return min(x, y); });"
        ],
        "description": "ds -> rmq_disjoint.cpp snippet"
    },
    "ds_rmq_self": {
        "prefix": "ds_rmq_self",
        "body": [
            "template <typename T, typename Compare>\nstruct rmq {\n    vector<vector<T>> d;\n    rmq(const vector<T> &A) { // [0, n)\n        int n = (int) A.size();\n        int log_n = 0;\n        while ((1 << log_n) <= n) log_n++;\n        d = vector<vector<T>>(n, vector<T>(log_n));\n        for (int i = 0; i < n; ++i) d[i][0] = A[i];\n        for (int j = 1; (1 << j) <= n; ++j) {\n            for (int i = 0; i + (1 << j) - 1 < n; ++i) {\n                d[i][j] = Compare()(d[i][j - 1], d[i + (1 << (j - 1))][j - 1]) ? d[i][j - 1] : d[i + (1 << (j - 1))][j - 1];\n            }\n        }\n    }\n    T query(int l, int r) { // [l, r)\n        int k = 0;\n        while (1 << (k + 1) <= r - l) k++;\n        return Compare()(d[l][k], d[r - (1 << k)][k]) ? d[l][k] : d[r - (1 << k)][k];\n    }\n};\ntemplate <typename T, typename Compare>\nstruct rmq2 {\n    vector<vector<T>> d;\n    vector<int> ref;\n    rmq2(const vector<T> &A) { // [0, n)\n        int n = (int) A.size();\n        int log_n = 0;\n        while ((1 << log_n) <= n) log_n++;\n        d = vector<vector<T>>(n, vector<T>(log_n));\n        for (int i = 0; i < n; ++i) {\n            d[i][0] = A[i];\n        }\n        for (int j = 1; (1 << j) <= n; ++j) {\n            for (int i = 0; i + (1 << j) - 1 < n; ++i) {\n                d[i][j] = Compare()(d[i][j - 1], d[i + (1 << (j - 1))][j - 1]) ? d[i][j - 1] : d[i + (1 << (j - 1))][j - 1];\n            }\n        }\n        ref = vector<int>(n + 1, 0); // pre calc the k\n        for (int i = 1; i <= n; ++i) {\n            int k = 0;\n            while (1 << (k + 1) <= i) k++;\n            ref[i] = k;\n        }\n    }\n    T query(int l, int r) { // [l, r), real O(1)\n        int k = ref[r - l];\n        return Compare()(d[l][k], d[r - (1 << k)][k]) ? d[l][k] : d[r - (1 << k)][k];\n    }\n};\nvoid test() {\n\tvector<int> data = {1, 5, 2, 4, 3};\n\trmq2<int, less<int>> rmqMin(data); // 使用默认的 std::less<>\n\trmq2<int, decltype([](const int& a, const int& b) { return a > b; })> rmqMax(data); // 使用自定义比较函数\n\trmq2<int, greater<int>> rmqMax1(data);\n\tint minVal = rmqMin.query(1, 3); // 查询最小值\n\tint maxVal = rmqMax.query(1, 3); // 查询最大值\n\tint maxVal1 = rmqMax1.query(1, 3); // 查询最大值\n\tcout << minVal << ' ' << maxVal << ' ' << maxVal1 << endl;\n}\n"
        ],
        "description": "ds -> rmq_self.cpp snippet"
    },
    "ds_segtree_atc_range_min_count": {
        "prefix": "ds_segtree_atc_range_min_count",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_en/lazysegtree.html\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n\t#define ATCODER_INTERNAL_BITOP_HPP 1\n\n\t#ifdef _MSC_VER\n\t\t#include <intrin.h>\n\t#endif\n\n\t#if __cplusplus >= 202002L\n\t\t#include <bit>\n\t#endif\n\n\tnamespace atcoder {\n\n\t\tnamespace internal {\n\n\t\t\t#if __cplusplus >= 202002L\n\n\t\t\t\tusing std::bit_ceil;\n\n\t\t\t#else\n\n\t\t\t\t// @return same with std::bit::bit_ceil\n\t\t\t\tunsigned int bit_ceil(unsigned int n) {\n\t\t\t\t\tunsigned int x = 1;\n\t\t\t\t\twhile (x < (unsigned int)(n)) x *= 2;\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\n\t\t\t#endif\n\n\t\t\t// @param n `1 <= n`\n\t\t\t// @return same with std::bit::countr_zero\n\t\t\tint countr_zero(unsigned int n) {\n\t\t\t\t#ifdef _MSC_VER\n\t\t\t\t\tunsigned long index;\n\t\t\t\t\t_BitScanForward(&index, n);\n\t\t\t\t\treturn index;\n\t\t\t\t#else\n\t\t\t\t\treturn __builtin_ctz(n);\n\t\t\t\t#endif\n\t\t\t}\n\n\t\t\t// @param n `1 <= n`\n\t\t\t// @return same with std::bit::countr_zero\n\t\t\t// constexpr int countr_zero_constexpr(unsigned int n) {\n\t\t\t// \tint x = 0;\n\t\t\t// \twhile (!(n & (1 << x))) x++;\n\t\t\t// \treturn x;\n\t\t\t// }\n\n\t\t}  // namespace internal\n\n\t}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n\n\n#ifndef ATCODER_LAZYSEGTREE_HPP\n\t#define ATCODER_LAZYSEGTREE_HPP 1\n\t#include <cassert>\n\t#include <functional>\n\t#include <vector>\n\n\tnamespace atcoder {\n\n\t\t#if __cplusplus >= 201703L\n\n\t\t\ttemplate <class S,\n\t\t\t\t\tauto op,\n\t\t\t\t\tauto e,\n\t\t\t\t\tclass F,\n\t\t\t\t\tauto mapping,\n\t\t\t\t\tauto composition,\n\t\t\t\t\tauto id>\n\t\t\tstruct lazy_segtree {\n\t\t\t\tstatic_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\n\t\t\t\t\t\t\t\"op must work as S(S, S)\");\n\t\t\t\tstatic_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\n\t\t\t\t\t\t\t\"e must work as S()\");\n\t\t\t\tstatic_assert(\n\t\t\t\t\tstd::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,\n\t\t\t\t\t\"mapping must work as F(F, S)\");\n\t\t\t\tstatic_assert(\n\t\t\t\t\tstd::is_convertible_v<decltype(composition), std::function<F(F, F)>>,\n\t\t\t\t\t\"compostiion must work as F(F, F)\");\n\t\t\t\tstatic_assert(std::is_convertible_v<decltype(id), std::function<F()>>,\n\t\t\t\t\t\t\t\"id must work as F()\");\n\n\t\t#else\n\n\t\t\ttemplate <class S,\n\t\t\t\t\tS (*op)(S, S),\n\t\t\t\t\tS (*e)(),\n\t\t\t\t\tclass F,\n\t\t\t\t\tS (*mapping)(F, S),\n\t\t\t\t\tF (*composition)(F, F),\n\t\t\t\t\tF (*id)()>\n\t\t\tstruct lazy_segtree {\n\n\t\t#endif\n\n\t\tpublic:\n\t\t\tlazy_segtree() : lazy_segtree(0) {}\n\t\t\texplicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n\t\t\texplicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n                size = (int)internal::bit_ceil((unsigned int)(_n));\n\t\t\t\tlog = internal::countr_zero((unsigned int)size);\n\t\t\t\td = std::vector<S>(2 * size, e());\n\t\t\t\tlz = std::vector<F>(size, id());\n\t\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\t\tupdate(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set(int p, S x) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = x;\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\n\t\t\tS get(int p) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\treturn d[p];\n\t\t\t}\n\n\t\t\tS prod(int l, int r) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return e();\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\tS sml = e(), smr = e();\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\t\tl >>= 1;\n\t\t\t\t\tr >>= 1;\n\t\t\t\t}\n\n\t\t\t\treturn op(sml, smr);\n\t\t\t}\n\n\t\t\tS all_prod() { return d[1]; }\n\n\t\t\tvoid apply(int p, F f) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = mapping(f, d[p]);\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\t\t\tvoid apply(int l, int r, F f) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return;\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tint l2 = l, r2 = r;\n\t\t\t\t\twhile (l < r) {\n\t\t\t\t\t\tif (l & 1) all_apply(l++, f);\n\t\t\t\t\t\tif (r & 1) all_apply(--r, f);\n\t\t\t\t\t\tl >>= 1;\n\t\t\t\t\t\tr >>= 1;\n\t\t\t\t\t}\n\t\t\t\t\tl = l2;\n\t\t\t\t\tr = r2;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i <= log; i++) {\n\t\t\t\t\tif (((l >> i) << i) != l) update(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) update((r - 1) >> i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t\tmax_right\n\t\t\t\t(1): It applies binary search on the segment tree. The function bool f(S x) should be defined.\n\t\t\t\t(2): The function object that takes S as the argument and returns bool should be defined.\n\n\t\t\t\tIt returns an index r that satisfies both of the following.\n\t\t\t\tr = l or f(op(a[l], a[l + 1], ..., a[r - 1])) = true\n\t\t\t\tr = n or f(op(a[l], a[l + 1], ..., a[r])) = false\n\n\t\t\t\tIf f is monotone, this is the maximum r that satisfies f(op(a[l], a[l + 1], ..., a[r - 1])) = true.\n\n\t\t\t\tConstraints\n\n\t\t\t\tif f is called with the same argument, it returns the same value, i.e., f has no side effect.\n\t\t\t\tf(e()) = true\n\t\t\t*/\n\t\t\ttemplate <bool (*g)(S)> int max_right(int l) {\n\t\t\t\treturn max_right(l, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int max_right(int l, G g) {\n\t\t\t\tassert(0 <= l && l <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (l == _n) return _n;\n\t\t\t\tl += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(l >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\t\tif (!g(op(sm, d[l]))) {\n\t\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\t\tpush(l);\n\t\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\t\tif (g(op(sm, d[l]))) {\n\t\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn l - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\tl++;\n\t\t\t\t} while ((l & -l) != l);\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int min_left(int r) {\n\t\t\t\treturn min_left(r, [](S x) { return g(x); });\n\t\t\t}\n\t\t\ttemplate <class G> int min_left(int r, G g) {\n\t\t\t\tassert(0 <= r && r <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (r == 0) return 0;\n\t\t\t\tr += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push((r - 1) >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\tr--;\n\t\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\t\tif (!g(op(d[r], sm))) {\n\t\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\t\tpush(r);\n\t\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\t\tif (g(op(d[r], sm))) {\n\t\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t} while ((r & -r) != r);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n, size, log;\n\t\t\tstd::vector<S> d;\n\t\t\tstd::vector<F> lz;\n\n\t\t\t// 上传\n\t\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\n\t\t\t// 对 k 应用懒标记\n\t\t\tvoid all_apply(int k, F f) {\n\t\t\t\td[k] = mapping(f, d[k]);\n\t\t\t\tif (k < size) lz[k] = composition(f, lz[k]);\n\t\t\t}\n\n\t\t\t// 懒标记下放\n\t\t\tvoid push(int k) {\n\t\t\t\tall_apply(2 * k, lz[k]);\n\t\t\t\tall_apply(2 * k + 1, lz[k]);\n\t\t\t\tlz[k] = id();\n\t\t\t}\n\t\t};\n\n\t}  // namespace atcoder\n\n#endif  // ATCODER_LAZYSEGTREE_HPP\nconst int inf = 1e9;\nstruct S {\n    int range_min, num;\n};\nstring toString(S s) {\n    return \"S = (\" + to_string(s.range_min) + \", \" + to_string(s.num) + \")\"; // CE\n}\nS op(S a, S b) {\n    if (a.range_min != b.range_min) {\n        if (a.range_min < b.range_min) {\n            return a;\n        } else {\n            return b;\n        }\n    } else {\n        return S{a.range_min, a.num + b.num};\n    }\n}\n// 注意验证是否x: S + e() == x\n// 考虑e() + e()如果不是e()有无影响\n// 注意确定每个节点的初始值是不是e()\nS e() {\n\treturn S{inf, 0};\n}\nstruct F {\n\tint64_t add = 0;\n};\nS mapping(F f, S s) {\n\ts.range_min += f.add;\n\treturn s;\n}\nF composition(F f, F g) {\n\tf.add += g.add;\n\treturn f;\n}\nF id() {\n\treturn F{0};\n}\nusing Tree = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;"
        ],
        "description": "ds -> segtree_atc_range_min_count.cpp snippet"
    },
    "ds_segtree_atc_std": {
        "prefix": "ds_segtree_atc_std",
        "body": [
            "// https://atcoder.github.io/ac-library/production/document_en/lazysegtree.html\n#ifndef ATCODER_INTERNAL_BITOP_HPP\n\t#define ATCODER_INTERNAL_BITOP_HPP 1\n\n\t#ifdef _MSC_VER\n\t\t#include <intrin.h>\n\t#endif\n\n\t#if __cplusplus >= 202002L\n\t\t#include <bit>\n\t#endif\n\n\tnamespace atcoder {\n\n\t\tnamespace internal {\n\n\t\t\t#if __cplusplus >= 202002L\n\n\t\t\t\tusing std::bit_ceil;\n\n\t\t\t#else\n\n\t\t\t\t// @return same with std::bit::bit_ceil\n\t\t\t\tunsigned int bit_ceil(unsigned int n) {\n\t\t\t\t\tunsigned int x = 1;\n\t\t\t\t\twhile (x < (unsigned int)(n)) x *= 2;\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\n\t\t\t#endif\n\n\t\t\t// @param n `1 <= n`\n\t\t\t// @return same with std::bit::countr_zero\n\t\t\tint countr_zero(unsigned int n) {\n\t\t\t\t#ifdef _MSC_VER\n\t\t\t\t\tunsigned long index;\n\t\t\t\t\t_BitScanForward(&index, n);\n\t\t\t\t\treturn index;\n\t\t\t\t#else\n\t\t\t\t\treturn __builtin_ctz(n);\n\t\t\t\t#endif\n\t\t\t}\n\n\t\t\t// @param n `1 <= n`\n\t\t\t// @return same with std::bit::countr_zero\n\t\t\t// constexpr int countr_zero_constexpr(unsigned int n) {\n\t\t\t// \tint x = 0;\n\t\t\t// \twhile (!(n & (1 << x))) x++;\n\t\t\t// \treturn x;\n\t\t\t// }\n\n\t\t}  // namespace internal\n\n\t}  // namespace atcoder\n\n#endif  // ATCODER_INTERNAL_BITOP_HPP\n\n\n#ifndef ATCODER_LAZYSEGTREE_HPP\n\t#define ATCODER_LAZYSEGTREE_HPP 1\n\t#include <cassert>\n\t#include <functional>\n\t#include <vector>\n\n\tnamespace atcoder {\n\n\t\t#if __cplusplus >= 201703L\n\n\t\t\ttemplate <class S,\n\t\t\t\t\tauto op,\n\t\t\t\t\tauto e,\n\t\t\t\t\tclass F,\n\t\t\t\t\tauto mapping,\n\t\t\t\t\tauto composition,\n\t\t\t\t\tauto id>\n\t\t\tstruct lazy_segtree {\n\t\t\t\tstatic_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,\n\t\t\t\t\t\t\t\"op must work as S(S, S)\");\n\t\t\t\tstatic_assert(std::is_convertible_v<decltype(e), std::function<S()>>,\n\t\t\t\t\t\t\t\"e must work as S()\");\n\t\t\t\tstatic_assert(\n\t\t\t\t\tstd::is_convertible_v<decltype(mapping), std::function<S(F, S)>>,\n\t\t\t\t\t\"mapping must work as F(F, S)\");\n\t\t\t\tstatic_assert(\n\t\t\t\t\tstd::is_convertible_v<decltype(composition), std::function<F(F, F)>>,\n\t\t\t\t\t\"compostiion must work as F(F, F)\");\n\t\t\t\tstatic_assert(std::is_convertible_v<decltype(id), std::function<F()>>,\n\t\t\t\t\t\t\t\"id must work as F()\");\n\n\t\t#else\n\n\t\t\ttemplate <class S,\n\t\t\t\t\tS (*op)(S, S),\n\t\t\t\t\tS (*e)(),\n\t\t\t\t\tclass F,\n\t\t\t\t\tS (*mapping)(F, S),\n\t\t\t\t\tF (*composition)(F, F),\n\t\t\t\t\tF (*id)()>\n\t\t\tstruct lazy_segtree {\n\n\t\t#endif\n\n\t\tpublic:\n\t\t\tlazy_segtree() : lazy_segtree(0) {}\n\t\t\texplicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n\t\t\texplicit lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n\t\t\t\tsize = (int)internal::bit_ceil((unsigned int)(_n));\n\t\t\t\tlog = internal::countr_zero((unsigned int)size);\n\t\t\t\td = std::vector<S>(2 * size, e());\n\t\t\t\tlz = std::vector<F>(size, id());\n\t\t\t\tfor (int i = 0; i < _n; i++) d[size + i] = v[i];\n\t\t\t\tfor (int i = size - 1; i >= 1; i--) {\n\t\t\t\t\tupdate(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid set(int p, S x) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = x;\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\n\t\t\tS get(int p) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\treturn d[p];\n\t\t\t}\n\n\t\t\tS prod(int l, int r) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return e();\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\tS sml = e(), smr = e();\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tif (l & 1) sml = op(sml, d[l++]);\n\t\t\t\t\tif (r & 1) smr = op(d[--r], smr);\n\t\t\t\t\tl >>= 1;\n\t\t\t\t\tr >>= 1;\n\t\t\t\t}\n\n\t\t\t\treturn op(sml, smr);\n\t\t\t}\n\n\t\t\tS all_prod() { return d[1]; }\n\n\t\t\tvoid apply(int p, F f) {\n\t\t\t\tassert(0 <= p && p < _n);\n\t\t\t\tp += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(p >> i);\n\t\t\t\td[p] = mapping(f, d[p]);\n\t\t\t\tfor (int i = 1; i <= log; i++) update(p >> i);\n\t\t\t}\n\t\t\tvoid apply(int l, int r, F f) {\n\t\t\t\tassert(0 <= l && l <= r && r <= _n);\n\t\t\t\tif (l == r) return;\n\n\t\t\t\tl += size;\n\t\t\t\tr += size;\n\n\t\t\t\tfor (int i = log; i >= 1; i--) {\n\t\t\t\t\tif (((l >> i) << i) != l) push(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) push((r - 1) >> i);\n\t\t\t\t}\n\n\t\t\t\t{\n\t\t\t\t\tint l2 = l, r2 = r;\n\t\t\t\t\twhile (l < r) {\n\t\t\t\t\t\tif (l & 1) all_apply(l++, f);\n\t\t\t\t\t\tif (r & 1) all_apply(--r, f);\n\t\t\t\t\t\tl >>= 1;\n\t\t\t\t\t\tr >>= 1;\n\t\t\t\t\t}\n\t\t\t\t\tl = l2;\n\t\t\t\t\tr = r2;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 1; i <= log; i++) {\n\t\t\t\t\tif (((l >> i) << i) != l) update(l >> i);\n\t\t\t\t\tif (((r >> i) << i) != r) update((r - 1) >> i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int max_right(int l) {\n\t\t\t\treturn max_right(l, [](S x) { return g(x); });\n\t\t\t}\n\n\t\t\t// the max index r satisfies: g(op(a[l], a[l + 1], ..., a[r - 1])) = true\n\t\t\ttemplate <class G> int max_right(int l, G g) {\n\t\t\t\tassert(0 <= l && l <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (l == _n) return _n;\n\t\t\t\tl += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push(l >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\twhile (l % 2 == 0) l >>= 1;\n\t\t\t\t\tif (!g(op(sm, d[l]))) {\n\t\t\t\t\t\twhile (l < size) {\n\t\t\t\t\t\t\tpush(l);\n\t\t\t\t\t\t\tl = (2 * l);\n\t\t\t\t\t\t\tif (g(op(sm, d[l]))) {\n\t\t\t\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\t\t\t\tl++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn l - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(sm, d[l]);\n\t\t\t\t\tl++;\n\t\t\t\t} while ((l & -l) != l);\n\t\t\t\treturn _n;\n\t\t\t}\n\n\t\t\ttemplate <bool (*g)(S)> int min_left(int r) {\n\t\t\t\treturn min_left(r, [](S x) { return g(x); });\n\t\t\t}\n\n\t\t\t// the min index l satisfies: g(op(a[l], a[l + 1], ..., a[r - 1])) = true\n\t\t\ttemplate <class G> int min_left(int r, G g) {\n\t\t\t\tassert(0 <= r && r <= _n);\n\t\t\t\tassert(g(e()));\n\t\t\t\tif (r == 0) return 0;\n\t\t\t\tr += size;\n\t\t\t\tfor (int i = log; i >= 1; i--) push((r - 1) >> i);\n\t\t\t\tS sm = e();\n\t\t\t\tdo {\n\t\t\t\t\tr--;\n\t\t\t\t\twhile (r > 1 && (r % 2)) r >>= 1;\n\t\t\t\t\tif (!g(op(d[r], sm))) {\n\t\t\t\t\t\twhile (r < size) {\n\t\t\t\t\t\t\tpush(r);\n\t\t\t\t\t\t\tr = (2 * r + 1);\n\t\t\t\t\t\t\tif (g(op(d[r], sm))) {\n\t\t\t\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t\t\t\t\tr--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn r + 1 - size;\n\t\t\t\t\t}\n\t\t\t\t\tsm = op(d[r], sm);\n\t\t\t\t} while ((r & -r) != r);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\tprivate:\n\t\t\tint _n, size, log;\n\t\t\tstd::vector<S> d;\n\t\t\tstd::vector<F> lz;\n\n\t\t\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n\n\t\t\tvoid all_apply(int k, F f) {\n\t\t\t\td[k] = mapping(f, d[k]);\n\t\t\t\tif (k < size) lz[k] = composition(f, lz[k]);\n\t\t\t}\n\n\t\t\tvoid push(int k) {\n\t\t\t\tall_apply(2 * k, lz[k]);\n\t\t\t\tall_apply(2 * k + 1, lz[k]);\n\t\t\t\tlz[k] = id();\n\t\t\t}\n\t\t};\n\n\t}  // namespace atcoder\n\n#endif  // ATCODER_LAZYSEGTREE_HPP\nconst int64_t inf = 1e18; \nstruct S {\n\tint64_t sm, num, mn, mx;\n};\nstring toString(S s) {\n    // return \"S\" + toString(vector{s.sm, s.mn, s.mx}); // 注意编译错误\n    return \"S = {\" \n    + to_string(s.sm) + \", \"\n    + to_string(s.num) + \", \"\n    + to_string(s.mn) + \", \"\n    + to_string(s.mx) + \"}\";\n}\nS op(S a, S b) {\n\ta.sm += b.sm;\n\ta.mn = min(a.mn, b.mn);\n\ta.mx = max(a.mx, b.mx);\n\ta.num += b.num;\n\treturn a;\n}\n// 验证x: S + e() == x, e() + e() ?= e()\n// 每个节点的初始值一般不是e(), 即tree(vector<S>(n, e()))往往是错的\nS e() { \n\treturn S{0, 0, inf, -inf};\n}\nstruct F {\n\tint64_t add = 0;\n};\nS mapping(F f, S s) {\n\ts.sm += f.add * s.num;\n\ts.mn += f.add;\n\ts.mx += f.add;\n\treturn s;\n}\nF composition(F f, F g) { // 注意特判f == id()时\n\tf.add += g.add;\n\treturn f;\n}\nF id() {\n\treturn F{};\n}\nusing T = atcoder::lazy_segtree<S, op, e, F, mapping, composition, id>;"
        ],
        "description": "ds -> segtree_atc_std.cpp snippet"
    },
    "ds_segtree_d": {
        "prefix": "ds_segtree_d",
        "body": [
            "struct segtree_d {\n\n    using ll = long long;\n    const ll mod = 1000000007;\n    struct tag {\n        ll mul, add;\n    };\n\n    tag compose(const tag &t1, const tag &t2) {\n        // (x * t1.mul + t1.add) * t2.mul + t2.add\n        return {t1.mul * t2.mul % mod, (t1.add * t2.mul + t2.add) % mod};\n    }\n\n    struct node {\n        tag t;\n        ll val;\n        int sz;\n    };\n    vector<node> seg;\n\n    segtree_d(int n) {\n        seg = vector<node>(n * 4 + 5);\n    }\n\n    void update(int id) {\n        seg[id].val = (seg[id * 2].val + seg[id * 2 + 1].val) % mod; \n        // 合并两孩子节点tag的时候，注意防止被孩子污染\n        // 即：不要写成father = compose(son_left, son_right)，此时有可能会误用孩子的tag\n    }\n\n    void settag(int id, tag t) {\n        seg[id].t = compose(seg[id].t, t);\n        seg[id].val = (seg[id].val * t.mul + seg[id].sz * t.add) % mod;\n    }\n\n    void pushdown(int id) {\n        if (seg[id].t.mul != 1 || seg[id].t.add != 0) { // 标记非空\n            settag(id * 2, seg[id].t);\n            settag(id * 2 + 1, seg[id].t);\n            seg[id].t.mul = 1;\n            seg[id].t.add = 0;\n        }\n    }\n\n    void build(int id, int l, int r, const vector<int> &a) {\n        seg[id].t = {1, 0};\n        seg[id].sz = r - l + 1;\n        if (l == r) {\n            seg[id].val = {a[l]};\n        } else {\n            int mid = (l + r) / 2;\n            build(id * 2, l, mid, a);\n            build(id * 2 + 1, mid + 1, r, a);\n            update(id);\n        }\n    }\n\n    // 节点为id，对应的区间为[l, r]，修改a[pos] -> val\n    void modify(int id, int l, int r, int ql, int qr, tag t) {\n        if (l == ql && r == qr) {\n            settag(id, t);\n            return;\n        }\n        int mid = (l + r) / 2;\n        // 重要‼️\n        pushdown(id);\n        if (qr <= mid) modify(id * 2, l, mid, ql, qr, t);\n        else if (ql > mid) modify(id * 2 + 1, mid + 1, r, ql, qr, t);\n        else {\n            modify(id * 2, l, mid, ql, mid, t);\n            modify(id * 2 + 1, mid + 1, r, mid + 1, qr, t);\n        }\n        // 重要‼️\n        update(id);\n    }\n\n    // [ql, qr]表示查询的区间\n    ll query(int id, int l, int r, int ql, int qr) {\n        if (l == ql && r == qr) return seg[id].val;\n        int mid = (l + r) / 2;\n        // 重要‼️\n        pushdown(id);\n        if (qr <= mid) return query(id * 2, l, mid, ql, qr);\n        else if (ql > mid) return query(id * 2 + 1, mid + 1, r, ql, qr);\n        else {\n            // qr > mid, ql <= mid\n            // [ql, mid], [mid + 1, qr]\n            return (query(id * 2, l, mid, ql, mid) + query(id * 2 + 1, mid + 1, r, mid + 1, qr)) % mod;\n        }\n    }\n};"
        ],
        "description": "ds -> segtree_d.cpp snippet"
    },
    "ds_segtree_d_simple": {
        "prefix": "ds_segtree_d_simple",
        "body": [
            "const int64_t inf = (int64_t) 1e18;\nstruct Segtree {\n    vector<int64_t> seg;\n\n    Segtree(int n) {\n        seg = vector<int64_t>(n * 4 + 1, inf);\n    }\n\n    int64_t compose(int64_t info0, int64_t info1) {\n        return min(info0, info1);\n    }\n\n    void update(int id) {\n        seg[id] = compose(seg[id * 2], seg[id * 2 + 1]);\n    }\n\n    void modify(int id, int l, int r, int pos, int64_t value) {\n        if (l == pos && r == pos) {\n            seg[id] = min(seg[id], value);\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (pos <= mid) modify(id * 2, l, mid, pos, value);\n        else modify(id * 2 + 1, mid + 1, r, pos, value);\n        update(id);\n    }\n\n    int64_t query(int id, int l, int r, int query_l, int query_r) {\n        if (l == query_l && r == query_r) return seg[id];\n        int mid = (l + r) / 2;\n        if (query_r <= mid) return query(id * 2, l, mid, query_l, query_r);\n        else if (query_l > mid) return query(id * 2 + 1, mid + 1, r, query_l, query_r);\n        else {\n            return compose(query(id * 2, l, mid, query_l, mid), query(id * 2 + 1, mid + 1, r, mid + 1, query_r));\n        }\n    }\n};"
        ],
        "description": "ds -> segtree_d_simple.cpp snippet"
    },
    "ds_segtree_range_assign_sum": {
        "prefix": "ds_segtree_range_assign_sum",
        "body": [
            "const int inf = (int) 1e9; \nstruct T {\n    T(int n) { // [1, n]\n        root = 0;\n        build(root, 1, n);\n    }\n    int query(int l, int r) { // [l, r]\n        return Q(root, l, r);\n    }\n    void update(int l, int r, int x) { // [l, r]\n        return U(root, l, r, x);\n    }\nprivate:\n    struct Node {\n        int l = 0, r = 0, sm = 0, lz = inf; // -1 表示没有懒标记\n        Node *ls = 0, *rs = 0;\n    } *root;\n    void build(Node*& p, int l, int r) {\n        p = new Node();\n        p->l = l;\n        p->r = r;\n        if (l != r) {\n            int mid = (l + r) >> 1;\n            build(p->ls, l, mid);\n            build(p->rs, mid + 1, r);\n        }\n    }\n    void xx(Node*&p, int x) {\n        p->sm = (p->r - p->l + 1) * x;\n        p->lz = x;\n    }\n    void xia(Node*& p) {\n        if (p->lz == inf) {\n            return;\n        }\n        xx(p->ls, p->lz);\n        xx(p->rs, p->lz);\n        p->lz = inf;\n    }\n    int Q(Node*& p, int l, int r) {\n        if (p->l > r || p->r < l) {\n            return 0;\n        }\n        if (l <= p->l && r >= p->r) {\n            return p->sm;\n        } else {\n            xia(p);\n            return Q(p->ls, l, r) + Q(p->rs, l, r);\n        }\n    }\n    void U(Node*& p, int l, int r, int x) {\n        if (p->l > r || p->r < l) {\n            return;\n        }\n        if (l <= p->l && r >= p->r) {\n            xx(p, x);\n        } else {\n            xia(p);\n            U(p->ls, l, r, x);\n            U(p->rs, l, r, x);\n            p->sm = p->ls->sm + p->rs->sm;\n        }\n    }\n};\nvoid test() {\n    int n, m;\n    cin >> n >> m;\n    T t(n);\n    for (int i = 1; i <= n; ++i) {\n        int x;\n        cin >> x;\n        t.update(i, i, x);\n    }\n    while (m--) {\n        int o;\n        cin >> o;\n        if (o == 1) {\n            int l, r, k;\n            cin >> l >> r >> k;\n            t.update(l, r, k);\n        } else {\n            int l, r;\n            cin >> l >> r;\n            cout << t.query(l, r) << '\\\\n';\n        }\n    }\n}\n"
        ],
        "description": "ds -> segtree_range_assign_sum.cpp snippet"
    },
    "ds_segtree_zkw": {
        "prefix": "ds_segtree_zkw",
        "body": [
            "template <typename T>\nstruct zkw {\n    static const T inf = 1e9, inf2 = 2e9;\n    // static const T inf = 1e18, inf2 = 2e18;\n    struct Node { \n        T sm, lz, mn, mx;\n        Node() {\n            sm = lz = 0, mn = inf, mx = -inf;\n        }\n        Node(T _sm, T _lz, T _mn, T _mx) {\n            sm = _sm, lz = _lz, mn = _mn, mx = _mx;\n        }\n    };\n    vector<Node> a;\n    int m;\n    // 线段树最后一层的下标范围是[m, 2m - 1]\n    // 将x的[0, n - 1]映射到[m + 1, m + n], 其中m + n < 2m - 1\n    void init(vector<T> x) {\n        int n = x.size() + 2;\n        for (m = 4; m < n; m <<= 1);\n        a.resize(m << 1);\n        for (int i = 0; i < (int) x.size(); i++) {\n            a[m + i + 1] = Node(x[i], 0, x[i], x[i]);\n        }\n        for (int i = m - 1; i >= 1; i--) {\n            T sm = a[i << 1].sm + a[i << 1 | 1].sm;\n            T lz = 0;\n            T mn = min(a[i << 1].mn, a[i << 1 | 1].mn);\n            T mx = max(a[i << 1].mx, a[i << 1 | 1].mx);\n            a[i] = Node(sm, lz, mn, mx);\n        }\n    }\n    void update(int l, int r, T delta) { // [l, r] += delta\n        int len = 1, cntl = 0, cntr = 0;\n        // 最后一层的开区间(l, r) += delta\n        for (l += m + 1 - 1, r += m + 1 + 1; l ^ r ^ 1; l >>= 1, r >>= 1, len <<= 1) {\n            if (l < m) {\n                a[l].mn = min(a[l << 1].mn, a[l << 1 | 1].mn) + a[l].lz;\n                a[l].mx = max(a[l << 1].mx, a[l << 1 | 1].mx) + a[l].lz;\n                a[l].sm += cntl * delta;\n                a[r].mn = min(a[r << 1].mn, a[r << 1 | 1].mn) + a[r].lz;\n                a[r].mx = max(a[r << 1].mx, a[r << 1 | 1].mx) + a[r].lz;\n                a[r].sm += cntr * delta;\n            }\n            if (~l & 1) {\n                a[l ^ 1].sm += len * delta;\n                a[l ^ 1].lz += delta;\n                a[l ^ 1].mn += delta;\n                a[l ^ 1].mx += delta;\n                cntl += len;\n            }\n            if (r & 1) {\n                a[r ^ 1].sm += len * delta;\n                a[r ^ 1].lz += delta;\n                a[r ^ 1].mn += delta;\n                a[r ^ 1].mx += delta;\n                cntr += len;\n            }\n        }\n        for (; l; l >>= 1, r >>= 1) {\n            a[l].mn = min(a[l << 1].mn, a[l << 1 | 1].mn) + a[l].lz;\n            a[l].mx = max(a[l << 1].mx, a[l << 1 | 1].mx) + a[l].lz;\n            a[l].sm += cntl * delta;\n            a[r].mn = min(a[r << 1].mn, a[r << 1 | 1].mn) + a[r].lz;\n            a[r].mx = max(a[r << 1].mx, a[r << 1 | 1].mx) + a[r].lz;\n            a[r].sm += cntr * delta;\n        }\n    }\n    // [l, r]的和, 最小值, 最大值, 注意, 可能返回inf +- 小范围的数\n    tuple<T, T, T> query(int l, int r) {\n        T sm = 0, lmn = inf2, lmx = -inf2, rmn = inf2, rmx = -inf2;\n        int len = 1, cntl = 0, cntr = 0;\n        for (l += m + 1 - 1, r += m + 1 + 1; l ^ r ^ 1; l >>= 1, r >>= 1, len <<= 1) {\n            sm += a[l].lz * cntl;\n            sm += a[r].lz * cntr;\n            lmn += a[l].lz;\n            lmx += a[l].lz;\n            rmn += a[r].lz;\n            rmx += a[r].lz;\n            if (~l & 1) {\n                sm += a[l ^ 1].sm;\n                lmn = min(lmn, a[l ^ 1].mn);\n                lmx = max(lmx, a[l ^ 1].mx);\n                cntl += len;\n            }\n            if (r & 1) {\n                sm += a[r ^ 1].sm;\n                rmn = min(rmn, a[r ^ 1].mn);\n                rmx = max(rmx, a[r ^ 1].mx);\n                cntr += len;\n            }\n        }\n        for (; l; l >>= 1, r >>= 1) {\n            sm += a[l].lz * cntl;\n            lmn += a[l].lz;\n            lmx += a[l].lz;\n            sm += a[r].lz * cntr;\n            rmn += a[r].lz;\n            rmx += a[r].lz;\n        }\n        T mn = max(-inf, min(lmn, rmn));\n        T mx = min(inf, max(lmx, rmx));\n        return make_tuple(sm, mn, mx);\n    }\n};\nvoid test() {\n    zkw<int> tree;\n    int n = 10000;\n    using T = int;\n    vector<T> x(n+1, 0);\n    vector<T> brute(n+1, 0);\n    for (int i = 1; i <= n; i++) {\n        x[i] = rand() % 2000 - 1000;\n        brute[i] = x[i];\n    }\n    tree.init(x);\n    for (int i = 0; i < 10000; i++) {\n        int op = rand() % 4; // 生成一个0到3之间的随机数，决定执行何种操作\n        int l = rand() % n + 1;\n        int r = rand() % (n - l + 1) + l;\n        if (op == 0) { // 区间修改操作\n            T delta = rand() % 2000 - 1000;\n            tree.update(l, r, delta);\n            for (int j = l; j <= r; j++)\n                brute[j] += delta;\n        } else if (op == 1) { // 区间查询和操作\n            auto res = tree.query(l, r);\n            T sum = get<0>(res);\n            T bruteSum = 0;\n            for (int j = l; j <= r; j++)\n                bruteSum += brute[j];\n            assert(sum == bruteSum);\n        } else if (op == 2) { // 区间查询最大值操作\n            auto res = tree.query(l, r);\n            T mx = get<2>(res);\n            T bruteMax = *max_element(brute.begin() + l, brute.begin() + r + 1);\n            assert(mx == bruteMax);\n        } else { // 区间查询最小值操作\n            auto res = tree.query(l, r);\n            T mn = get<1>(res);\n            T bruteMin = *min_element(brute.begin() + l, brute.begin() + r + 1);\n            assert(mn == bruteMin);\n        }\n    }\n    cout << \"passed!\\\\n\";\n}"
        ],
        "description": "ds -> segtree_zkw.cpp snippet"
    },
    "ds_trie": {
        "prefix": "ds_trie",
        "body": [
            "using Info = int;\nstruct Node {\n    Info info = 0;\n    array<int, 2> sons = {-1, -1};\n};\nInfo compose(Info i, const Info& other) {\n    return ...\n}\nvector<Node> tree(1);\nvoid add(vector<int> char_seq, Info info) {\n    int cur = 0;\n    tree[cur].info = compose(tree[cur].info, info);\n    for (auto i : char_seq) {\n        auto& soni = tree[cur].sons[i];\n        if (soni == -1) {\n            tree.push_back(Node());\n            soni = (int) tree.size() - 1;\n        }\n        cur = soni;\n        tree[cur].info = compose(tree[cur].info, info);\n    }\n}\nInfo query(vector<int> char_seq) {\n    int cur = 0;\n    for (auto i : char_seq) {\n        cur = tree[cur].sons[i];\n        if (cur == -1) {\n            ...\n        }\n    }\n    return tree[cur].info;\n}"
        ],
        "description": "ds -> trie.cpp snippet"
    },
    "ds_zhu": {
        "prefix": "ds_zhu",
        "body": [
            "namespace zhu { // 主席树模板\n#define mid ((l + r) >> 1)\n#define lc (o << 1)\n#define rc (o << 1 | 1)\n    typedef long long LL;\n    const int LOG = 20;\n    int n, m, q, tot = 0;\n    int a[N], b[N];\n    int T[N], sum[N * LOG], L[N * LOG], R[N * LOG];\n\n    inline int build(int l, int r) {\n        int rt = ++tot;\n        if (l < r) L[rt] = build(l, mid), R[rt] = build(mid + 1, r);\n        return rt;\n    }\n\n    inline int update(int pre, int l, int r, int x) {\n        int rt = ++tot;\n        L[rt] = L[pre];\n        R[rt] = R[pre];\n        sum[rt] = sum[pre] + 1;\n        if (l != r) {\n            if (x <= mid) L[rt] = update(L[pre], l, mid, x);\n            else R[rt] = update(R[pre], mid + 1, r, x);\n        }\n        return rt;\n    }\n\n    inline int query(int u, int v, int l, int r, int k) {\n        if (l == r) return l;\n        int x = sum[L[v]] - sum[L[u]];\n        if (x >= k) return query(L[u], L[v], l, mid, k);\n        else return query(R[u], R[v], mid + 1, r, k - x);\n    }\n\n    void init(int *_a, int _n) {\n        tot = 0;\n        n = _n;\n        memset(T, 0, sizeof T);\n        memset(L, 0, sizeof L);\n        memset(R, 0, sizeof R);\n        memset(sum, 0, sizeof sum);\n        for (int i = 1; i <= n; i++) a[i] = _a[i], b[i] = a[i];\n        std::sort(b + 1, b + 1 + n);\n        m = std::unique(b + 1, b + 1 + n) - b - 1;\n        T[0] = build(1, m);\n        for (int i = 1; i <= n; i++) {\n            a[i] = std::lower_bound(b + 1, b + 1 + m, a[i]) - b, T[i] = update(T[i - 1], 1, m, a[i]);\n        }\n    }\n\n    int query(int x, int y, int z) {\n        int p = query(T[x - 1], T[y], 1, m, z);\n        return b[p];\n    }\n}\n"
        ],
        "description": "ds -> zhu.cpp snippet"
    },
    "geometry_geometry": {
        "prefix": "geometry_geometry",
        "body": [
            "typedef double db;\nconst db EPS = 1e-9;\n\ninline int sign(db a) { return a < -EPS ? -1 : a > EPS; }\n\n// 误差会累计 a == b, b == c, 但是a != c\ninline int cmp(db a, db b){ return sign(a-b); }\n\nstruct P {\n    db x, y;\n    P() {}\n    P(db _x, db _y) : x(_x), y(_y) {}\n    P operator+(P p) { return {x + p.x, y + p.y}; }\n    P operator-(P p) { return {x - p.x, y - p.y}; }\n    P operator*(db d) { return {x * d, y * d}; }\n    P operator/(db d) { return {x / d, y / d}; }\n\n    bool operator<(P p) const { \n        int c = cmp(x, p.x);\n        if (c) return c == -1;\n        return cmp(y, p.y) == -1;\n    }\n\n    bool operator==(P o) const{\n        return cmp(x,o.x) == 0 && cmp(y,o.y) == 0;\n    }\n\n    db dot(P p) { return x * p.x + y * p.y; }\n\n    // 叉积，不满足交换律，等价于有向四边形面积\n    // a.x * b.y - a.y * b.x\n    // 等价于a逆时针旋转不超过180读对应的有向四边形的面积\n    db det(P p) { return x * p.y - y * p.x; }\n\n    db distTo(P p) { return (*this-p).abs(); }\n\n    // [0,180] -> [0, pi], [360 -> 180] -> [0, -pi], 计算极角\n    // long double版本的话是atan2l\n    db alpha() { return atan2(y, x); }\n\n    void read() { cin>>x>>y; }\n    void write() {cout<<\"(\"<<x<<\",\"<<y<<\")\"<<endl;}\n\n    // hypot(x,y) = sqrt(x^2 + y^2), 但是不快\n    // long double版本是sqrtl()\n    db abs() { return sqrt(abs2());} \n    db abs2() { return x * x + y * y; }\n    P rot90() { return P(-y, x); }\n    P unit() { return *this / abs(); } // 方向向量\n\n    // 判断是否是[0, 180)\n    int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }\n\n    // 复数乘法，模长相乘幅角相加 (x + yi) * (cosx + isinx)\n    P rot(db an){ return {x*cos(an) - y*sin(an),x*sin(an) + y*cos(an)}; }\n};\n\n// (p1 -> p2) × (p1 -> p3)\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\n// 判断符号, 三个点的位置, =0共线, >0逆时针, <0顺时针\n#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))\n\n// 直线 p1p2, q1q2 是否恰有一个交点, 有可能共线\n// 先判断p1与(q1 -> q2)的关系\n// 再判断p2与(q1 -> q2)的关系并取负号\nbool chkLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return sign(a1+a2) != 0;\n}\n\n// 求直线 p1p2, q1q2 的交点\n// p1 p2 q1 q2这个四边形用两次对角线等比分点\nP isLL(P p1, P p2, P q1, P q2) {\n    db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);\n    return (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\n// 判断区间 [l1, r1], [l2, r2] 是否相交\nbool intersect(db l1,db r1,db l2,db r2){\n    if (l1>r1) swap(l1,r1); if (l2>r2) swap(l2,r2); \n    return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );\n}\n\n// 线段 p1p2, q1q2 相交\nbool isSS(P p1, P p2, P q1, P q2){\n    return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && \n        crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)\n        * crossOp(q1,q2,p2) <= 0;\n}\n\n// 线段 p1p2, q1q2 严格相交  \nbool isSS_strict(P p1, P p2, P q1, P q2){\n    return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) < 0 && crossOp(q1,q2,p1)\n        * crossOp(q1,q2,p2) < 0;\n}\n\n// m 在 a 和 b 之间, 并不是中间\n// 不一定是 a < b\nbool isMiddle(db a, db m, db b) {\n    /*if (a > b) swap(a, b);\n      return cmp(a, m) <= 0 && cmp(m, b) <= 0;*/\n    return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);\n}\n\n// 水\nbool isMiddle(P a, P m, P b) {\n    return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);\n}\n\n// 点 p 在线段 p1p2 上\nbool onSeg(P p1, P p2, P q){\n    return crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2); \n    // 这里 == 0，容易超1e18，容易出现精度问题\n    // 这里的corssOp已经用了sign了\n    // 如果已经确定了q在p1,p2所处的直线上，那么可以省略&&左侧的部分\n}\n\n// 点 p 严格在 p1p2 上\nbool onSeg_strict(P p1, P p2, P q){\n    return crossOp(p1,p2,q) == 0 && sign((q-p1).dot(p1-p2)) * sign((q-p2).dot(p1-p2)) < 0;\n}\n\n// 求 q 到 直线p1p2 的投影（垂足） ⚠️ : p1 != p2\n// 使用了点积等于投影后相乘\nP proj(P p1, P p2, P q) {\n    P dir = p2 - p1;\n    return p1 + dir * (dir.dot(q - p1) / dir.abs2());\n}\n\n// 求 q 以 直线p1p2 为轴的反射\nP reflect(P p1, P p2, P q){\n    return proj(p1,p2,q) * 2 - q;\n}\n\n// 求 q 到 线段p1p2 的最小距离\ndb nearest(P p1, P p2, P q){\n    if (p1 == p2) return p1.distTo(q);\n    P h = proj(p1,p2,q);\n    if(isMiddle(p1,h,p2))\n        return q.distTo(h);\n    return min(p1.distTo(q),p2.distTo(q));\n}\n\n// 求 线段p1p2 与 线段q1q2 的距离\ndb disSS(P p1, P p2, P q1, P q2){\n    if(isSS(p1,p2,q1,q2)) return 0;\n    return min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)));\n}\n\n// 极角排序\nsort(p, p + n, [&](P a, P b) {\n    int qa = a.quad(), qb = b.quad();\n    if (qa != qb) return qa < qb;\n    else return sign(a.det(b)) > 0;\n});\n\n"
        ],
        "description": "geometry -> geometry.cpp snippet"
    },
    "graph_dfs": {
        "prefix": "graph_dfs",
        "body": [
            "struct Dfs {\n    const int default_root = 0;\n    int B;\n    vector<vector<int>> fas, g;\n    vector<int> dep, fa, top, hson, siz, dft, the;\n    int dfs_time;\n    explicit Dfs(const int n) {\n        assert(n > 0);\n        if (n - 1 <= 1) { // (1 << B) >= n - 1, 最多跳n - 1次\n            B = 0;\n        } else {\n            int top_bit = 63 - __builtin_clzll(n - 1);\n            int more_bit = __builtin_popcountll(n - 1) > 1;\n            B = top_bit + more_bit;\n        }\n        fas.assign(n, vector<int>(B + 1, default_root));\n        g = vector<vector<int>>(n);\n        dep = fa = top = hson = siz = dft = the = vector<int>(n);\n        dfs_time = 0;\n    }  \n    void add_edge(const int x, const int y) {\n        g[x].push_back(y), g[y].push_back(x);\n    }\n    void dfs1(const int x, const int f) {\n        fa[x] = f;\n        siz[x] = 1;\n        hson[x] = -1;\n        for (auto v : g[x]) {\n            if (v != f) {\n                fas[x][0] = f;\n                for (int i = 1; i <= B; i++) {\n                    fas[x][i] = fas[fas[x][i - 1]][i - 1];\n                }\n                dep[v] = dep[x] + 1;\n                dfs1(v, x);\n                siz[x] += siz[v];\n                if (hson[x] == -1 || siz[v] > siz[hson[x]]) {\n                    hson[x] = v;\n                }\n            }\n        }\n    }\n    void dfs2(const int x, const int top_node) {\n        top[x] = top_node;\n        the[dfs_time] = x;\n        dft[x] = dfs_time++;\n        if (hson[x] == -1) {\n            return;\n        }\n        dfs2(hson[x], top_node);\n        for (const auto v : g[x]) {\n            if (v != fa[x] && v != hson[x]) {\n                dfs2(v, v);\n            }\n        }\n    }\n    int lca(int u, int v) {\n        while (top[u] != top[v]) {\n            if (dep[top[u]] < dep[top[v]]) v = fa[top[v]];\n            else u = fa[top[u]];\n        }\n        if (dep[u] < dep[v]) return u;\n        else return v;\n    }\n};\n"
        ],
        "description": "graph -> dfs.cpp snippet"
    },
    "graph_dij": {
        "prefix": "graph_dij",
        "body": [
            "using T = pair<int, int>;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    vector<vector<int>> g;\n    vector<int> dis, vis;\n    priority_queue<T, vector<T>, greater<T>> pq;\n\n    dis[0] = ...;\n    pq.emplace(0, dis[0]);\n    \n    while (!pq.empty()) {\n        auto [d, u] = pq.top(); pq.pop();\n        if (vis[u]) continue;\n        vis[u] = 1; // 如果不适用vis，只是用dis判断，可能由多个dis[u]相等的u点进入堆，导致u点重复扩展多次\n        for (auto i : g[u]) {\n            if (dis[i] > dis[u] + D(u, i)) {\n                dis[i] = dis[u] + D(u, i);\n                pq.emplace(i, dis[i]);\n            }\n        }\n    }\n    return 0;\n}"
        ],
        "description": "graph -> dij.cpp snippet"
    },
    "graph_dsu": {
        "prefix": "graph_dsu",
        "body": [
            "struct dsu {\n    vector<int> p; // father\n    vector<int> s; // size\n    long long cur = 0; // num of edge\n    long long calc(long long x) {\n        return x * (x - 1) / 2;\n    }\n    dsu(int n) : p(n + 1), s(n + 1, 1) { \n        iota(p.begin(), p.end(), 0); \n    }\n    int find(int x) { \n        return p[x] == x ? x : p[x] = f(p[x]); \n    }\n    void unite(int x, int y) { \n        int f1 = find(x), f2 = find(y);\n        long long n1 = s[f1], n2 = s[f2];\n        cur -= calc(n2) + calc(n1);\n        cur += calc(n1 + n2);\n        p[f2] = f1;\n        s[f1] += s[f2];\n    }\n    bool equal(int x, int y) { \n        return find(x) == find(y); \n    }\n};"
        ],
        "description": "graph -> dsu.cpp snippet"
    },
    "graph_dsu_on_tree": {
        "prefix": "graph_dsu_on_tree",
        "body": [
            "vector<vector<int>> e;\nvector<int> big_son, l, r;\nint n;\nint64_t ans;\nvoid dfs(int u, int f, bool keep) {\n    for (auto v : e[u]) {\n        if (v != f && v != big_son[u]) {\n            dfs(v, u, 0); // 每个轻儿子回答询问，不保留贡献\n        }\n    }\n    if (big_son[u] != -1) {\n        dfs(big_son[u], u, 1); // 保留重儿子的贡献\n    }\n    for (auto v : e[u]) {\n        if (v != f && v != big_son[u]) {\n            for (int i = l[v]; i <= r[v]; i++) { // 每个轻儿子的贡献（通过dfs序），其实是启发式合并的过程\n                // add dfs_time_id[i]\n            }\n        }\n    }\n    // add u !!!\n    // ...\n    if (!keep) {\n        for (int i = l[u]; i <= r[u]; i++) {\n            // delete dfs_time_id[i]\n        }\n    }\n}\n\n\n// example\nfunction<void(int, int, bool)> dfs = [&](const int u, const int f, const bool keep) {\n    for (auto v : d.g[u]) {\n        if (v != f && v != d.bson[u]) {\n            dfs(v, u, false);\n        }\n    }\n    if (d.bson[u] != -1) {\n        dfs(d.bson[u], u, true);\n    }\n    for (auto v : d.g[u]) {\n        if (v != f && v != d.bson[u]) {\n            for (int time = d.dft[v]; time < d.dft[v] + d.siz[v]; time++) { // 每个轻儿子的贡献（通过dfs序），等价于启发式合并的过程\n                add_color(c[d.the[time]]);\n            }\n        }\n    }\n    add_color(c[u]); // !!!\n    ans[u] = cnt_sum[max_cnt];\n    if (!keep) {\n        for (int time = d.dft[u]; time < d.dft[u] + d.siz[u]; time++) {\n            del_color(c[d.the[time]]);\n        }\n    }\n};\ndfs(0, 0, true);"
        ],
        "description": "graph -> dsu_on_tree.cpp snippet"
    },
    "graph_KuhnMunkres": {
        "prefix": "graph_KuhnMunkres",
        "body": [
            "#include <tool/tool.h>\n#include <algorithm>\n#include <iostream>\n#include <string.h>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n\n#define xding(x) priority_queue<x, vector<x>, greater<x> >\n#define dding(x) priority_queue<x, vector<x>, less<x> >\n#define fb(x,a,b) for(long long x = (a); x <= (b); ++x)\n#define fk(x,a,b) for(long long x = (a); x < (b); ++x)\n#define rall(x) x.rbegin(),x.rend()\n#define eh(x,y) for(auto &x : y)\n#define all(x) x.begin(),x.end()\n#define sz(x) ((int)x.size())\n#define pb push_back\n#define ins insert\n#define se second\n#define fi first\n#define V vector\n\nusing namespace std;\ntypedef vector<pair<long long, long long> > vpll;\ntypedef vector<vector<vector<int> > > vvvi;\ntypedef pair<long long, long long> pll;\ntypedef vector<pair<int, int> > vpii;\ntypedef vector<vector<int> > vvi;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long double ld;\ntypedef long double ld;\ntypedef long long ll;\ntypedef double db;\n\nconst char end1 = '\\\\n';\nconst int N = (int)503;\nint con[N][N]; // 临界矩阵\nint n, m, e;\nint zuomatch[N]; // zuomatch[i] = j表示左侧的第i个与右侧的第j的相匹配了\nint youmatch[N]; // 同上\nint qian[N];\nint ischeck[N]; // 用于记录右侧节点是否被检查过\nint main() {\n    ios::sync_with_stdio(!cin.tie(0));\n    memset(zuomatch, -1, sizeof zuomatch);\n    memset(youmatch, -1, sizeof youmatch);\n    memset(qian, -1, sizeof qian);\n    memset(ischeck, -1, sizeof ischeck);\n    cin >> n >> m >> e; // 左侧节点数, 右侧节点数, 边数\n    int a, b;\n    while (e--) { // 邻接矩阵\n        cin >> a >> b; // 左侧的a可以与右侧的b相连\n        con[a][b] = 1;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        queue<int> Q;\n        Q.push(i);\n        int you = 0;\n        while (Q.size() && you == 0) {\n            int u = Q.front(); Q.pop(); // u是当前左侧节点\n            for (int v = 1; v <= m && you == 0; ++v) { // v是与u相连的右侧节点\n                if (con[u][v] == 0 || ischeck[v] == i) continue; // ischeck[v] == i, 表示v节点在第i轮被访问过, 第i论就是本轮\n                ischeck[v] = i;\n                if (youmatch[v] != -1) { // 节点v已经被匹配了\n                    qian[youmatch[v]] = u; // 记录youmatch[v]是因谁而被迫入队的\n                    Q.push(youmatch[v]);\n                } else {\n                    you = 1;\n                    while (u != -1) {\n                        int z = zuomatch[u];\n                        zuomatch[u] = v, youmatch[v] = u;\n                        u = qian[u], v = z; // u永远是左侧节点, v永远是右侧节点\n                    }\n                }\n            }\n        }\n        ans += you;\n    }\n    cout << ans << end1;\n    return 0;\n}\n\n\n\n\n  "
        ],
        "description": "graph -> KuhnMunkres.cpp snippet"
    },
    "graph_lca": {
        "prefix": "graph_lca",
        "body": [
            "struct LCA {\n    vector<vector<int>> f;\n    vector<int> dep;\n    const int k = 20;\n    void init(int n, vector<vector<int>> g) {\n        f = vector<vector<int>>(n + 1, vector<int>(k + 1, 1));\n        dep = vector<int>(n + 1, 0);\n        function<void(int, int)> dfs = [&](int u, int x) {\n            for (int v: g[u]) {\n                if (v != x) {\n                    f[v][0] = u;\n                    for (int i = 1; i <= k; ++i) {\n                        f[v][i] = f[f[v][i - 1]][i - 1];\n                    }\n                    dep[v] = dep[u] + 1;\n                    // 必须先算f[v][...]，再做dfs\n                    dfs(v, u);\n                }\n            }\n        };\n        dfs(1, 0);\n    }\n    int lca(int u, int v) {\n        if (dep[u] > dep[v]) {\n            swap(u, v);\n        }\n        for (int i = k; i >= 0; --i) {\n            if (dep[f[v][i]] >= dep[u]) {\n                v = f[v][i];\n            }\n        }\n        if (u == v) {\n            return u;\n        }\n        for (int i = k; i >= 0; --i) {\n            if (f[u][i] != f[v][i]) {\n                u = f[u][i];\n                v = f[v][i];\n            }\n        }\n        assert(u != v and f[u][0] == f[v][0]);\n        return f[u][0]; // 父节点是LCA\n    };\n};\n\n"
        ],
        "description": "graph -> lca.cpp snippet"
    },
    "graph_lca_o1": {
        "prefix": "graph_lca_o1",
        "body": [
            "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n    #include <other/debug.h>\n#else\n    #define debug(...) 0\n#endif\nusing namespace std;\nusing pli = pair<int64_t, int>;\nunsigned int A, B, C;\ninline unsigned int rng61() {\n    A ^= A << 16;\n    A ^= A >> 5;\n    A ^= A << 1;\n    unsigned int t = A;\n    A = B;\n    B = C;\n    C ^= t ^ A;\n    return C;\n}\ntemplate <typename A, typename B>\nbool ckmn(A &x, const B &y) {\n    return x > y && (x = y, true);\n}\ntemplate <typename A, typename B>\nbool ckmx(A &x, const B &y) {\n    return x < y && (x = y, true);\n}\nstruct rmq {\n    using Compare = less<pli>;\n    vector<vector<pair<int64_t, int>>> d;\n    rmq(const vector<pli> &a) { // [0, n)\n        int n = (int) a.size();\n        int log_n = 0;\n        while ((1 << log_n) <= n) log_n++;\n        d = vector<vector<pli>>(n, vector<pli>(log_n));\n        for (int i = 0; i < n; ++i) d[i][0] = a[i];\n        for (int j = 1; (1 << j) <= n; ++j) {\n            for (int i = 0; i + (1 << j) - 1 < n; ++i) {\n                d[i][j] = Compare()(d[i][j - 1], d[i + (1 << (j - 1))][j - 1]) ? d[i][j - 1] : d[i + (1 << (j - 1))][j - 1];\n            }\n        }\n    }\n    pli query(int l, int r) { // [l, r)\n        int k = 0;\n        while (1 << (k + 1) <= r - l) k++;\n        return Compare()(d[l][k], d[r - (1 << k)][k]) ? d[l][k] : d[r - (1 << k)][k];\n    }\n};\nint main(){\n    const int inf = (int) 1e9;\n    int n, m;\n    scanf(\"%d%d%u%u%u\", &n, &m, &A, &B, &C);\n    vector<vector<int>> g(n);\n    {\n        for (int i = 0; i < n - 1; ++i) {\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            --a, --b;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n    }\n    vector<int> p(n, inf), dep(n, 0);\n    vector<int64_t> s;\n    function<void(int, int)> dfs = [&](int u, int father) {\n        s.push_back(u);\n        ckmn(p[u], int(s.size()) - 1);\n        for (auto v : g[u]) {\n            if (v == father) {\n                continue;\n            }\n            dep[v] = dep[u] + 1;\n            dfs(v, u);\n            s.push_back(u);\n        }\n    };\n    dfs(0, 0);\n    vector<pli> a(s.size());\n    for (int i = 0; i < int(s.size()); ++i) {\n        a[i] = {dep[s[i]], s[i]};\n    }\n    rmq r(a);\n    function<int(int, int)> lca = [&](int u, int v) -> int {\n        --u, --v;\n        int iu = p[u], iv = p[v];\n        if (iu > iv) {\n            swap(iu, iv);\n        }\n        return r.query(iu, iv + 1).second;\n    };\n    long long ans = 0;\n    for (int i = 1; i <= m; i++) {\n        unsigned int u = rng61() % n + 1, v = rng61() % n + 1;\n        long long ans_i = lca(u, v) + 1;\n        ans ^= ans_i * i;\n    }\n    printf(\"%lld\\\\n\", ans);\n}"
        ],
        "description": "graph -> lca_o1.cpp snippet"
    },
    "graph_max_clique": {
        "prefix": "graph_max_clique",
        "body": [
            "struct MC {\n    int x[105][105];\n    int z[105][105];\n    int best;\n    int bests[105];\n    int n;\n    int dfs(int ceng, int m) { // ceng shi zui datuan, m shi ke kuo zhan dian\n        if (m == 0) {\n            if (ceng > best) {\n                best = ceng;\n                return 1;\n            }\n            return 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            if (m - i + ceng <= best) { // sheng yu dian jian zhi\n                return 0;\n            }\n            int u = z[ceng][i];\n            if (bests[u] + ceng <= best) { // xia jie jian zhi\n                return 0;\n            }\n            int ji = 0;\n            for (int j = i + 1; j < m; ++j) {\n                if (x[u][z[ceng][j]]) {\n                    z[ceng + 1][ji++] = z[ceng][j];\n                }\n            }\n            if (dfs(ceng + 1, ji)) {\n                return 1;\n            }\n        }\n    }\n    int max_clique() {\n        best = 0;\n        memset(bests, 0, sizeof(bests));\n        for (int i = n - 1; i >= 0; --i) {\n            int ji = 0;\n            for (int j = i + 1; j < n; ++j) {\n                if (x[i][j]) {\n                    z[1][ji++] = j;\n                }\n            }\n            dfs(1, ji);\n            bests[i] = best;\n        }\n        return best;\n    }\n} mc;"
        ],
        "description": "graph -> max_clique.cpp snippet"
    },
    "graph_mcmf": {
        "prefix": "graph_mcmf",
        "body": [
            "// ___mcmf\nnamespace mcmf {\n    int ret; // 最小花费\n    const int N = 5e3 + 5, M = 1e5 + 5; // 点数不要设过大, 不然memset开销太大\n    const int INF = 0x3f3f3f3f;\n    int lnk[N], ter[M], nxt[M], tot = 1; // 链式前向星\n    int cap[M], cost[M]; // 容量和单位花费\n    void add(int u, int v, int w, int c) {\n        ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot;\n        cap[tot] = w, cost[tot] = c;\n    }\n    void addedge(int u, int v, int w, int c) {\n        add(u, v, w, c);\n        add(v, u, 0, -c);\n    }\n    int dis[N]; // 到每个点的最小单位花费\n    bool vis[N]; // vis 不用memset, 因为dfs设为1与设为0抵消\n    int cur[N]; // 当前弧\n    bool spfa(int s, int t) {\n        memset(dis, 0x3f, sizeof(dis));\n        memcpy(cur, lnk, sizeof(lnk));\n        std::queue<int> q;\n        q.push(s), dis[s] = 0, vis[s] = 1;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop(), vis[u] = 0;\n            for (int i = lnk[u]; i; i = nxt[i]) {\n                int v = ter[i];\n                if (cap[i] && dis[v] > dis[u] + cost[i]) {\n                    dis[v] = dis[u] + cost[i];\n                    if (!vis[v]) q.push(v), vis[v] = 1;\n                }\n            }\n        }\n        return dis[t] != INF;\n    }\n    int dfs(int u, int t, int flow) {\n        if (u == t) return flow;\n        vis[u] = 1;\n        int ans = 0;\n        for (int &i = cur[u]; i && ans < flow; i = nxt[i]) {\n            int v = ter[i];\n            if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]) {\n                int x = dfs(v, t, std::min(cap[i], flow - ans));\n                if (x) ret += x * cost[i], cap[i] -= x, cap[i ^ 1] += x, ans += x;\n            }\n        }\n        vis[u] = 0;\n        return ans;\n    }\n    int mcmf(int s, int t) {\n        int ans = 0;\n        while (spfa(s, t)) {\n            int x;\n            while ((x = dfs(s, t, INF))) ans += x;\n        }\n        return ans;\n    }\n}\n"
        ],
        "description": "graph -> mcmf.cpp snippet"
    },
    "graph_shupou": {
        "prefix": "graph_shupou",
        "body": [
            "// ___shupou\n#include <bits/stdc++.h>\nusing namespace std;\n// declaration\nstring to_string(char);\nstring to_string(char*);\nstring to_string(bool);\nstring to_string(string);\ntemplate <typename A, typename B>\nstring to_string(pair<A, B>);\ntemplate <typename T>\nstring to_string(priority_queue<T>);\ntemplate <typename T>\nstring to_string(stack<T>);\ntemplate <typename T>\nstring to_string(queue<T> x);\ntemplate <typename T>\nstring to_string(T x);\n// implementation\nstring to_string(char x) {\n    return \"'\" + string() + x + \"'\";\n}\nstring to_string(const char* s) {\n    return string(s);\n}\nstring to_string(bool x) {\n    if (x) return \"true\";\n    else return \"false\";\n}\nstring to_string(string s) {\n    return \"\\\\\"\" + s + \"\\\\\"\";\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> x) {\n    return \"(\" + to_string(x.first) + \", \" + to_string(x.second) + \")\";\n}\ntemplate <typename T>\nstring to_string(priority_queue<T> x) {\n    vector<T> v;\n    while (!x.empty()) {\n        v.push_back(x.top());\n        x.pop();\n    }\n    return to_string(v);\n}\ntemplate <typename T>\nstring to_string(stack<T> x) {\n    vector<T> v;\n    while (!x.empty()) {\n        v.push_back(x.top());\n        x.pop();\n    }\n    return to_string(v);\n}\ntemplate <typename T>\nstring to_string(queue<T> x) {\n    vector<T> v;\n    while (!x.empty()) {\n        v.push_back(x.front());\n        x.pop();\n    }\n    return to_string(v);\n}\ntemplate <typename T>\nstring to_string(T v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto& x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\nvoid debug_out() {\n    cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n#define fuck(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\n#define em emplace\n#define eb emplace_back\n#define sz(x) ((int)x.size())\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define send {ios::sync_with_stdio(0);}\n#define help {cin.tie(0);}\n#define fn0(x) for (int i = 0; i < x; ++i)\n#define fn1(x) for (int i = 1; i <= x; ++i)\n#define nf1(x) for (int i = (x); i >= 1; --i)\n#define nf0(x) for (int i = (x - 1); i >= 0; --i)\n#define fsz(i, a) for (int i = 0; i < sz(a); ++i)\n#define fk(i, a, b) for (int i = (a); i < (b); ++i)\n#define fb(i, a, b) for (int i = (a); i <= (b); ++i)\n#define fan(i, a, b) for (int i = (a); i >= (b); --i)\n#define eh(i, x) for (auto& i : x)\nusing namespace std;\nusing i32 = int;\nusing ll = long long;\nusing i64 = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing si = set<int>;\nusing sl = set<ll>;\nusing mii = map<int, int>;\nusing mll = map<ll, ll>;\ntemplate <typename T>\nusing S = set<T>;\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T>\nusing Q = queue<T>;\ntemplate <typename T>\nusing DQ = deque<T>;\ntemplate <typename T>\nusing ST = stack<T>;\ntemplate <typename T, typename _T>\nusing MP = map<T, _T>;\ntemplate <typename T, typename _T>\nusing P = pair<T, _T>;\ntemplate <typename T>\nusing DAP = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T>\nusing XIP = priority_queue<T, vector<T>, greater<T>>;\nusing vvi = V<vi>;\nusing vvl = V<vl>;\nusing vvvi = V<vvi>;\nusing vvvl = V<vvl>;\nusing vpii = V<pii>;\nusing vpll = V<pll>;\ntemplate <typename T>\nll Min(T a) {\n    return (ll)a;\n}\ntemplate <typename Head, typename... Tail>\nll Min(Head H, Tail... T) {\n    return min((ll)H, Min(T...));\n}\ntemplate <typename T>\nll Max(T a) {\n    return (ll)a;\n}\ntemplate <typename Head, typename... Tail>\nll Max(Head H, Tail... T) {\n    return max((ll)H, Max(T...));\n}\ntemplate <typename T>\nll Gcd(T a) {\n    return a;\n}\ntemplate <typename Head, typename... Tail>\nll Gcd(Head H, Tail... T) {\n    return __gcd((ll)H, Gcd(T...));\n}\n// declaration\ntemplate <typename T> void cao(T);\ntemplate <typename T> void cao(vector<T>&);\ntemplate <typename T> void cao(set<T>&);\ntemplate <typename A, typename... B> void cao(A, B...);\n// implementation\ntemplate <typename T>\nvoid cao(T x) {\n    cout << x << '\\\\n';\n}\ntemplate <typename T>\nvoid cao(vector<T>& x) {\n    bool is = false;\n    for (auto& i : x) {\n        if (is) cout << ' ';\n        is = true;\n        cout << i;\n    }\n    cout << '\\\\n';\n}\ntemplate <typename T>\nvoid cao(set<T>& a) {\n    bool is = false;\n    for (auto& i : a) {\n        if (is) cout << ' ';\n        is = true;\n        cout << i;\n    }\n    cout << '\\\\n';\n}\ntemplate <typename Head, typename... Tail>\nvoid cao(Head H, Tail... T) {\n    cout << H << ' ';\n    cao(T...);\n}\n// declaration\ntemplate <typename T> istream& operator >> (istream&, set<T>&);\ntemplate <typename T> istream& operator >> (istream&, vector<T>&);\ntemplate <typename A, typename B> istream& operator >> (istream&, P<A, B>&);\n// implementation\ntemplate <typename T>\nistream& operator >> (istream& in, vector<T>& x) {\n    for (auto& i : x) in >> i;\n    return in;\n}\ntemplate <typename A, typename B>\nistream& operator >> (istream& in, P<A, B>& x) {\n    in >> x.fi >> x.se;\n    return in;\n}\n// declaration\ntemplate <typename T> void Cin(T&);\ntemplate <typename A, typename... B> void Cin(A&, B&...);\n// implementation\ntemplate <typename T>\nvoid Cin(T& x) {\n    cin >> x;\n}\ntemplate <typename A, typename... B>\nvoid Cin(A& a, B&... b) {\n    cin >> a;\n    Cin(b...);\n}\nconst char end1 = '\\\\n';//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nconst int N = (int)1e5 + 5;\n#define lowbit(x) ((x)&(-x))\nll sum1[N];\nll sum2[N];\nvoid update(int p, ll dx)\n{\n    for (ll i = p; i < N; i += lowbit(i))\n    {\n        sum1[i] += dx;\n        sum2[i] += p * dx;\n    }\n}\nvoid update(int l, int r, ll dx)\n{\n    update(l, dx), update(r + 1, -dx);\n}\nll query(int p)\n{\n    ll res = 0;\n    for (ll i = p; i > 0; i -= lowbit(i))\n    {\n        res += (p + 1) * sum1[i] - sum2[i];\n    }\n    return res;\n}\nll query(int l, int r)\n{\n    return query(r) - query(l - 1);\n}\nll mod;\nconst int maxn = (int)1e5 + 5;\nvi G[maxn];\nint w[maxn];\nint dep[maxn], fa[maxn], son[maxn], siz[maxn];\nint dfn[maxn], tt;\nint id[maxn];\nint top[maxn];\nvoid dfs1(int u) {\n    siz[u] = 1;\n    for (int k = 0; k < sz(G[u]); k++) {\n        int v = G[u][k];\n        if (v == fa[u]) continue;\n        dep[v] = dep[u] + 1;\n        fa[v] = u;\n        dfs1(v);\n        siz[u] += siz[v];\n        if (siz[v] > siz[son[u]]) {\n            son[u] = v;\n        }\n    }\n}\nvoid dfs2(int u, int x) {\n    dfn[u] = ++tt;\n    id[tt] = u;\n    top[u] = x;\n    if (!son[u]) return;\n    dfs2(son[u], x);\n    for (int k = 0; k < sz(G[u]); k++) {\n        int v = G[u][k];\n        if (v == fa[u] || v == son[u]) continue;\n        dfs2(v, v);\n    }\n}\nll qTree(int u) {\n    return query(dfn[u], dfn[u] + siz[u] - 1);\n}\nvoid uTree(int u, int dx) {\n    update(dfn[u], dfn[u] + siz[u] - 1, dx);\n}\nll qPath(int u, int v) {\n    ll ans = 0;\n    while (top[u] != top[v]) {\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        ans = (ans + query(dfn[top[u]], dfn[u])) % mod;\n        u = fa[top[u]];\n    }\n    if (dep[u] > dep[v]) swap(u, v);\n    ans = (ans + query(dfn[u], dfn[v])) % mod;\n    return ans;\n}\nvoid uPath(int u, int v, int dx) {\n    while (top[u] != top[v]) {\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        update(dfn[top[u]], dfn[u], dx);\n        u = fa[top[u]];\n    }\n    if (dep[u] > dep[v]) swap(u, v);\n    update(dfn[u], dfn[v], dx);\n}\nint main() {\n    send help\n    int n, m, r;\n    cin >> n >> m >> r >> mod;\n    ll wei[maxn];\n    fb (i, 1, n) cin >> wei[i];\n    int u, v;\n    fb (i, 1, n - 1) {\n        cin >> u >> v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n    dfs1(r);\n    dfs2(r, r);\n    vi init(n + 5);\n    fb (i, 1, n) {\n        init[dfn[i]] = wei[i];\n    }\n    fan (i, n, 1) {\n        init[i] -= init[i - 1];\n    }\n    fb (i, 1, n) {\n        update(i, init[i]);\n    }\n    int op, z;\n    while (m--) {\n        cin >> op;\n        switch (op) {\n            case 1: {\n                cin >> u >> v >> z;\n                uPath(u, v, z);\n                break;\n            }\n            case 2: {\n                cin >> u >> v;\n                cao(ll(qPath(u, v) % mod));\n                break;\n            }\n            case 3: {\n                cin >> u >> z;\n                uTree(u, z);\n                break;\n            }\n            case 4: {\n                cin >> u;\n                cao(ll(qTree(u) % mod));\n                break;\n            }\n        }\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        ],
        "description": "graph -> shupou.cpp snippet"
    },
    "graph_tarjan": {
        "prefix": "graph_tarjan",
        "body": [
            "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define sz(x) ((int)x.size())\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define send {ios::sync_with_stdio(0);}\n#define help {cin.tie(0);}\n#define fk(i, a, b) for (int i = (a); i < (b); ++i)\n#define fb(i, a, b) for (int i = (a); i <= (b); ++i)\n#define fan(i, a, b) for (int i = (a); i >= (b); --i)\n#define eh(i, x) for (auto& i : x)\nusing namespace std;\nusing vi = vector<int>;\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T>\nusing ST = stack<T>;\nconst int N = (int) 5e3 + 5;\nvi G[N];\nST<int> st;\nint inst[N];\nint dfn[N];\nint low[N];\nint _clock = 0;\nV<vi> ans;\nvoid tarjan(int p) {\n    dfn[p] = low[p] = ++_clock;\n    st.push(p);\n    inst[p] = 1;\n    eh (i, G[p]) {\n        if (dfn[i] == 0) {\n            tarjan(i);\n            low[p] = min(low[p], low[i]);\n        }\n        else if (inst[i] == 1) {\n            low[p] = min(low[p], dfn[i]);\n        }\n    }\n    if (dfn[p] == low[p]) {\n        vi z;\n        while (1) {\n            int tp = st.top();\n            st.pop();\n            z.pb(tp);\n            inst[tp] = 0;\n            if (tp == p) break;\n        }\n        ans.pb(z);\n    }\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int a, b, c;\n    while (m--) {\n        scanf(\"%d %d %d\", &a, &b, &c);\n        G[a].pb(b);\n        if (c == 2) G[b].pb(a);\n    }\n    fb (i, 1, n) G[0].pb(i);\n    tarjan(0);\n    eh (i, ans) {\n        sort(all(i));\n        i.erase(unique(all(i)), i.end());\n    }\n    // print(ans);\n    return 0;\n}\n\n\n\n"
        ],
        "description": "graph -> tarjan.cpp snippet"
    },
    "greedy_garsiawachs": {
        "prefix": "greedy_garsiawachs",
        "body": [
            "// POJ 1738\n\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nconst int N = (int) 5e4 + 5;\nint a[N];\nint n;\nint main() {\n    while (scanf(\"%d\", &n), n) {\n        for (int i = 1; i <= n; ++i) {\n            scanf(\"%d\", a + i);\n        }\n        if (n == 1) {\n            puts(\"0\");\n            continue;\n        }\n        int ans = 0;\n        int left = 1;\n        while (left < n - 1) {\n            int k;\n            for (k = left; k < n - 1; ++k) {\n                if (a[k] <= a[k + 2]) {\n                    a[k + 1] += a[k];\n                    ans += a[k + 1];\n                    for (int j = k; j > left; --j) {\n                        a[j] = a[j - 1];\n                    }\n                    ++left;\n                    int j = k + 1;\n                    while (a[j] > a[j - 1] && j > left) {\n                        swap(a[j], a[j - 1]);\n                        --j;\n                    }\n                    break;\n                }\n            }\n            if (k == n - 1) {\n                a[n - 1] += a[n];\n                ans += a[--n];\n            }\n        }\n        ans += a[n - 1] + a[n];\n        printf(\"%d\\\\n\", ans);\n    }\n    return 0;\n}"
        ],
        "description": "greedy -> garsiawachs.cpp snippet"
    },
    "language_binary_search": {
        "prefix": "language_binary_search",
        "body": [
            "template <typename F>\nint64_t binary_search(F check, int64_t ok, int64_t ng, bool check_ok = true) {\n    if (check_ok) {\n        assert(check(ok) == true);\n        assert(check(ng) == false);\n    }\n    while (abs(ok - ng) > 1) { // 返回最接近ng的ok\n        auto x = (ng + ok) / 2;\n        tie(ok, ng) = (check(x) ? make_pair(x, ng) : make_pair(ok, x));\n    }\n    return ok;\n}\ntemplate <typename F>\nlong double binary_search_float(F check, long double ok, long double ng, int iter = 100) {\n    while (iter--) {\n        double x = (ok + ng) / 2;\n        tie(ok, ng) = (check(x) ? make_pair(x, ng) : make_pair(ok, x));\n    }\n    return (ok + ng) / 2;\n}\n"
        ],
        "description": "language -> binary_search.cpp snippet"
    },
    "language_bit": {
        "prefix": "language_bit",
        "body": [
            "/*\nc++20\nbit_cast\nbyteswap\nhas_single_bit\nbit_ceil\nbit_floor\nbit_width\nrotl\nrotr\ncountl_zero\ncountl_one\ncountr_zero\ncountr_one\npopcount\n*/\nint topbit(uint64_t x) {\n    return (x == 0 ? -1 : 63 - __builtin_clzll(x)); \n}\nint lowbit(uint64_t x) {\n    return (x == 0 ? -1 : __builtin_ctzll(x));\n}\nint popcnt(uint64_t x) {\n    return __builtin_popcountll(x);\n}\nbool have_bit(uint64_t x, int p) {\n    return x >> p & 1;\n}\nbool no_bit(uint64_t x, int p) {\n    return !hasbit(x, p);\n}\n"
        ],
        "description": "language -> bit.cpp snippet"
    },
    "language_celi_floor_div": {
        "prefix": "language_celi_floor_div",
        "body": [
            "template <typename T, typename U>\nT ceil(T x, U y) {\n    return (x > 0 ? (x + y - 1) / y : x / y);\n}\ntemplate <typename T, typename U>\nT floor(T x, U y) {\n    return (x > 0 ? x / y : (x - y + 1) / y);\n}\ntemplate <typename t, typename u>\npair<t, t> Div(t x, u y) {\n    t q = floor(x, y);\n    return {q, x - q * y};\n}"
        ],
        "description": "language -> celi_floor_div.cpp snippet"
    },
    "language_ckmin_ckmax": {
        "prefix": "language_ckmin_ckmax",
        "body": [
            "template <typename A, typename B>\nbool ckmn(A &x, const B &y) {\n    return x > y && (x = y, true);\n}\ntemplate <typename A, typename B>\nbool ckmx(A &x, const B &y) {\n    return x < y && (x = y, true);\n}"
        ],
        "description": "language -> ckmin_ckmax.cpp snippet"
    },
    "language_fastio": {
        "prefix": "language_fastio",
        "body": [
            "static struct FastInput {\n    static constexpr int BUF_SIZE = 1 << 20;\n    char buf[BUF_SIZE];\n    size_t chars_read = 0;\n    size_t buf_pos = 0;\n    FILE* in = stdin;\n    char cur = 0;\n\n    inline char get_char() {\n        if (buf_pos >= chars_read) {\n            chars_read = fread(buf, 1, BUF_SIZE, in);\n            buf_pos = 0;\n            buf[0] = (chars_read == 0 ? -1 : buf[0]);\n        }\n        return cur = buf[buf_pos++];\n    }\n\n    inline void tie(int) {}\n\n    inline explicit operator bool() {\n        return cur != -1;\n    }\n\n    inline static bool is_blank(char c) {\n        return c <= ' ';\n    }\n\n    inline bool skip_blanks() {\n        while (is_blank(cur) && cur != -1) {\n            get_char();\n        }\n        return cur != -1;\n    }\n\n    inline FastInput& operator>>(char& c) {\n        skip_blanks();\n        c = cur;\n        return *this;\n    }\n\n    inline FastInput& operator>>(string& s) {\n        if (skip_blanks()) {\n            s.clear();\n            do {\n                s += cur;\n            } while (!is_blank(get_char()));\n        }\n        return *this;\n    }\n\n    template <typename T>\n    inline FastInput& read_integer(T& n) {\n        // unsafe, doesn't check that characters are actually digits\n        n = 0;\n        if (skip_blanks()) {\n            int sign = +1;\n            if (cur == '-') {\n                sign = -1;\n                get_char();\n            }\n            do {\n                n += n + (n << 3) + cur - '0';\n            } while (!is_blank(get_char()));\n            n *= sign;\n        }\n        return *this;\n    }\n\n    template <typename T>\n    inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n        return read_integer(n);\n    }\n\n#if !defined(_WIN32) || defined(_WIN64)\n    inline FastInput& operator>>(__int128& n) {\n        return read_integer(n);\n    }\n#endif\n\n    template <typename T>\n    inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n        // not sure if really fast, for compatibility only\n        n = 0;\n        if (skip_blanks()) {\n            string s;\n            (*this) >> s;\n            sscanf(s.c_str(), \"%lf\", &n);\n        }\n        return *this;\n    }\n} fast_input;\n\nstatic struct FastOutput {\n    static constexpr int BUF_SIZE = 1 << 20;\n    char buf[BUF_SIZE];\n    size_t buf_pos = 0;\n    static constexpr int TMP_SIZE = 1 << 20;\n    char tmp[TMP_SIZE];\n    FILE* out = stdout;\n\n    inline void put_char(char c) {\n        buf[buf_pos++] = c;\n        if (buf_pos == BUF_SIZE) {\n            fwrite(buf, 1, buf_pos, out);\n            buf_pos = 0;\n        }\n    }\n\n    ~FastOutput() {\n        fwrite(buf, 1, buf_pos, out);\n    }\n\n    inline FastOutput& operator<<(char c) {\n        put_char(c);\n        return *this;\n    }\n\n    inline FastOutput& operator<<(const char* s) {\n        while (*s) {\n            put_char(*s++);\n        }\n        return *this;\n    }\n\n    inline FastOutput& operator<<(const string& s) {\n        for (int i = 0; i < (int)s.size(); i++) {\n            put_char(s[i]);\n        }\n        return *this;\n    }\n\n    template <typename T>\n    inline char* integer_to_string(T n) {\n        // beware of TMP_SIZE\n        char* p = tmp + TMP_SIZE - 1;\n        if (n == 0) {\n            *--p = '0';\n        } else {\n            bool is_negative = false;\n            if (n < 0) {\n                is_negative = true;\n                n = -n;\n            }\n            while (n > 0) {\n                *--p = (char)('0' + n % 10);\n                n /= 10;\n            }\n            if (is_negative) {\n                *--p = '-';\n            }\n        }\n        return p;\n    }\n\n    template <typename T>\n    inline typename enable_if<is_integral<T>::value, char*>::type stringify(T n) {\n        return integer_to_string(n);\n    }\n\n#if !defined(_WIN32) || defined(_WIN64)\n    inline char* stringify(__int128 n) {\n        return integer_to_string(n);\n    }\n#endif\n\n    template <typename T>\n    inline typename enable_if<is_floating_point<T>::value, char*>::type stringify(T n) {\n        sprintf(tmp, \"%.17f\", n);\n        return tmp;\n    }\n\n    template <typename T>\n    inline FastOutput& operator<<(const T& n) {\n        auto p = stringify(n);\n        for (; *p != 0; p++) {\n            put_char(*p);\n        }\n        return *this;\n    }\n} fast_output;\n\n#define cout fast_output"
        ],
        "description": "language -> fastio.cpp snippet"
    },
    "language_oiwikiio": {
        "prefix": "language_oiwikiio",
        "body": [
            "struct IO {\n    #define MAXSIZE ((1 << 20))\n    #define isdigit(x) (x >= '0' && x <= '9')\n    char buf[MAXSIZE], *p1, *p2;\n    char pbuf[MAXSIZE], *pp;\n    \n    IO() : p1(buf), p2(buf), pp(pbuf) {}\n    ~IO() {\n        fwrite(pbuf, 1, pp - pbuf, stdout);\n    }\n\n    char gc() {\n        if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);\n        return p1 == p2 ? ' ' : *p1++;\n    }\n\n    bool blank(char ch) {\n        return ch == ' ' || ch == '\\\\n' || ch == '\\\\r' || ch == '\\\\t';\n    }\n\n    template <class T>\n    void read(T &x) {\n        double tmp = 1;\n        bool sign = false;\n        x = 0;\n        char ch = gc();\n        for (; !isdigit(ch); ch = gc())\n            if (ch == '-') sign = 1;\n        for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');\n        if (ch == '.')\n            for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0');\n        if (sign) x = -x;\n    }\n\n    void read(char *s) {\n        char ch = gc();\n        for (; blank(ch); ch = gc());\n        for (; !blank(ch); ch = gc()) *s++ = ch;\n        *s = 0;\n    }\n\n    void read(char &c) {\n        for (c = gc(); blank(c); c = gc());\n    }\n\n    void push(const char &c) {\n        if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;\n        *pp++ = c;\n    }\n\n    template <class T>\n    void write(T x) {\n        if (x < 0) x = -x, push('-');  // 负数输出\n        static T sta[35];\n        T top = 0;\n        do {\n            sta[top++] = x % 10, x /= 10;\n        } while (x);\n        while (top) push(sta[--top] + '0');\n    }\n\n    template <class T>\n    void write(T x, char lastChar) {\n        write(x), push(lastChar);\n    }\n} io;"
        ],
        "description": "language -> oiwikiio.cpp snippet"
    },
    "math_big_int": {
        "prefix": "math_big_int",
        "body": [
            "struct BigInt : vector<int>//用标准库vector做基类，完美解决位数问题，同时更易于实现\n{\n    //将低精度转高精度的初始化，可以自动被编译器调用\n    //因此无需单独写高精度数和低精度数的运算函数，十分方便\n    BigInt(int n = 0)//默认初始化为0，但0的保存形式为空\n    {\n        push_back(n);\n        check();\n    }\n    BigInt &check()//在各类运算中经常用到的进位小函数，不妨内置\n    {\n        while (!empty() && !back())pop_back();//去除最高位可能存在的0\n        if (empty())return *this;\n        for (int i = 1; i < (int) size(); ++i) {\n            (*this)[i] += (*this)[i - 1] / 10;\n            (*this)[i - 1] %= 10;\n        }\n        while (back() >= 10) {\n            push_back(back() / 10);\n            (*this)[size() - 2] %= 10;\n        }\n        return *this;//为使用方便，将进位后的自身返回引用\n    }\n};\n//输入输出\nistream &operator>>(istream &is, BigInt &n) {\n    string s;\n    is >> s;\n    n.clear();\n    for (int i = (int) s.size() - 1; i >= 0; --i)n.push_back(s[i] - '0');\n    return is;\n}\nostream &operator<<(ostream &os, const BigInt &n) {\n    if (n.empty())os << 0;\n    for (int i = (int) n.size() - 1; i >= 0; --i)os << n[i];\n    return os;\n}\n//比较，只需要写两个，其他的直接代入即可\n//常量引用当参数，避免拷贝更高效\nbool operator!=(const BigInt &a, const BigInt &b) {\n    if (a.size() != b.size())return 1;\n    for (int i = (int) a.size() - 1; i >= 0; --i)\n        if (a[i] != b[i])return 1;\n    return 0;\n}\nbool operator==(const BigInt &a, const BigInt &b) {\n    return !(a != b);\n}\nbool operator<(const BigInt &a, const BigInt &b) {\n    if (a.size() != b.size())return a.size() < b.size();\n    for (int i = (int) a.size() - 1; i >= 0; --i)\n        if (a[i] != b[i])return a[i] < b[i];\n    return 0;\n}\nbool operator>(const BigInt &a, const BigInt &b) {\n    return b < a;\n}\nbool operator<=(const BigInt &a, const BigInt &b) {\n    return !(a > b);\n}\nbool operator>=(const BigInt &a, const BigInt &b) {\n    return !(a < b);\n}\n//加法，先实现+=，这样更简洁高效\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n    if (a.size() < b.size())a.resize(b.size());\n    for (int i = 0; i != (int) b.size(); ++i)a[i] += b[i];\n    return a.check();\n}\nBigInt operator+(BigInt a, const BigInt &b) {\n    return a += b;\n}\n//减法，返回差的绝对值，由于后面有交换，故参数不用引用\nBigInt &operator-=(BigInt &a, BigInt b) {\n    if (a < b)swap(a, b);\n    for (int i = 0; i != (int) b.size(); a[i] -= b[i], ++i)\n        if (a[i] < b[i])//需要借位\n        {\n            int j = i + 1;\n            while (!a[j])++j;\n            while (j > i) {\n                --a[j];\n                a[--j] += 10;\n            }\n        }\n    return a.check();\n}\nBigInt operator-(BigInt a, const BigInt &b) {\n    return a -= b;\n}\n//乘法不能先实现*=，原因自己想\nBigInt operator*(const BigInt &a, const BigInt &b) {\n    BigInt n;\n    n.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i != (int) a.size(); ++i)\n        for (int j = 0; j != (int) b.size(); ++j)\n            n[i + j] += a[i] * b[j];\n    return n.check();\n}\nBigInt &operator*=(BigInt &a, const BigInt &b) {\n    return a = a * b;\n}\n//除法和取模先实现一个带余除法函数\nBigInt divmod(BigInt &a, const BigInt &b) {\n    BigInt ans;\n    for (int t = (int) a.size() - (int) b.size(); a >= b; --t) {\n        BigInt d;\n        d.assign(t + 1, 0);\n        d.back() = 1;\n        BigInt c = b * d;\n        while (a >= c) {\n            a -= c;\n            ans += d;\n        }\n    }\n    return ans;\n}\nBigInt operator/(BigInt a, const BigInt &b) {\n    return divmod(a, b);\n}\nBigInt &operator/=(BigInt &a, const BigInt &b) {\n    return a = a / b;\n}\nBigInt &operator%=(BigInt &a, const BigInt &b) {\n    divmod(a, b);\n    return a;\n}\nBigInt operator%(BigInt a, const BigInt &b) {\n    return a %= b;\n}\nBigInt pow(const BigInt &n, const BigInt &k) {\n    if (k.empty())return 1;\n    if (k == 2)return n * n;\n    if (k.back() % 2)return n * pow(n, k - 1);\n    return pow(pow(n, k / 2), 2);\n}"
        ],
        "description": "math -> big_int.cpp snippet"
    },
    "math_exgcd_reverse": {
        "prefix": "math_exgcd_reverse",
        "body": [
            "int Exgcd(int a, int b, int &x, int &y) {\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = Exgcd(b, a % b, x, y);\n    int t = x;\n    x = y;\n    y = t - (a / b) * y;\n    return d;\n}\n\nvoid exgcd(int a, int b, int& d, int& x, int& y) {\n    if (!b) { d = a; x = 1; y = 0; }\n    else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }\n}\nconst int mod = 998244353;\nint ni(int a) { // a * x + mod * y == 1\n    int d, x, y;\n    exgcd(a, mod, d, x, y);\n    assert(d == 1);\n    return (x % mod + mod) % mod;\n}"
        ],
        "description": "math -> exgcd_reverse.cpp snippet"
    },
    "math_linear_prime": {
        "prefix": "math_linear_prime",
        "body": [
            "const int N = (int) 1e7 + 5;\nint cntp = 0;\nvector<int> pri, pri_ord(N, 0), min_factor(N, 0);\nbool not_prime[N];\nvoid init() {\n    for (int i = 2; i < N; ++i) {\n        if (!not_prime[i]) {\n            pri.push_back(i);\n            pri_ord[i] = cntp++;\n            min_factor[i] = i;\n        }\n        for (int pri_j : pri) {\n            if (i * pri_j >= N) break;\n            not_prime[i * pri_j] = true;\n            min_factor[i * pri_j] = pri_j;\n            if (i % pri_j == 0) {\n                break;\n            }\n        }\n    }\n}"
        ],
        "description": "math -> linear_prime.cpp snippet"
    },
    "math_mint": {
        "prefix": "math_mint",
        "body": [
            "template <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\n   public:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod())\n            v = static_cast<Type>(x);\n        else\n            v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const {\n        return value;\n    }\n    template <typename U>\n    explicit operator U() const {\n        return static_cast<U>(value);\n    }\n    constexpr static Type mod() {\n        return T::value;\n    }\n\n    Modular& operator+=(const Modular& other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular& operator-=(const Modular& other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template <typename U>\n    Modular& operator+=(const U& other) {\n        return *this += Modular(other);\n    }\n    template <typename U>\n    Modular& operator-=(const U& other) {\n        return *this -= Modular(other);\n    }\n    Modular& operator++() {\n        return *this += 1;\n    }\n    Modular& operator--() {\n        return *this -= 1;\n    }\n    Modular operator++(int) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(int) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const {\n        return Modular(-value);\n    }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) {\n        return *this *= Modular(inverse(other.value, mod()));\n    }\n\n    friend const Type& abs(const Modular& x) {\n        return x.value;\n    }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename V, typename U>\n    friend V& operator>>(V& stream, Modular<U>& number);\n\n   private:\n    Type value;\n};\n\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return lhs.value == rhs.value;\n}\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) {\n    return lhs == Modular<T>(rhs);\n}\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) == rhs;\n}\n\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) {\n    return !(lhs == rhs);\n}\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) {\n    return !(lhs == rhs);\n}\n\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return lhs.value < rhs.value;\n}\n\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) {\n    return Modular<T>(lhs) += rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) += rhs;\n}\n\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) {\n    return Modular<T>(lhs) -= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) -= rhs;\n}\n\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) {\n    return Modular<T>(lhs) *= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) *= rhs;\n}\n\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) {\n    return Modular<T>(lhs) /= rhs;\n}\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) {\n    return Modular<T>(lhs) /= rhs;\n}\n\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstring toString(const Modular<T>& number) {\n    return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, long long>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\n/*\nusing ModType = int;\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value; // cin >> md;\nusing Mint = Modular<VarMod>;\n*/\n\n/*\nconstexpr int md = 998244353;\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n*/\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n     if (k < 0 || k > n) {\n        return 0;\n     }\n     while ((int) fact.size() < n + 1) {\n           fact.push_back(fact.back() * (int) fact.size());\n           inv_fact.push_back(1 / fact.back());\n     }\n     return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\n// vector<Mint> fact(N);\n// vector<Mint> inv_fact(N);\n\n// void init() {\n//     fact[0] = 1;\n//     for (int i = 1; i < N; i++) {\n//         fact[i] = fact[i - 1] * i;\n//     }\n//     inv_fact[N - 1] = 1 / fact[N - 1];\n//     for (int i = N - 2; i >= 0; i--) {\n//         inv_fact[i] = inv_fact[i + 1] * (i + 1);\n//     }\n// }\n\n// Mint C(int n, int k) {\n//     assert(k >= 0 && n >= 0);\n//     if (k > n) {\n//         return 0;\n//     }\n//     return fact[n] * inv_fact[k] * inv_fact[n - k];\n// }\n\n// vector<Mint> fast_inv(N); // linear inverse\n// void init_fast_inv() {\n//     fast_inv[1] = 1;\n//     for (int i = 2; i < N; i++) {\n//         fast_inv[i] = fast_inv[md % i] * (md - md / i);\n//     }\n// }\n"
        ],
        "description": "math -> mint.cpp snippet"
    },
    "math_random": {
        "prefix": "math_random",
        "body": [
            "class RanGenerator {\nprivate:\n    std::mt19937_64 rng;\npublic:\n    RanGenerator(): rng(random_device{}()) {}\n    template <typename T>\n    T mtrand(T n) { // [0, n)\n        std::uniform_int_distribution<T> dist(0, n - 1);\n        return dist(rng);\n    }\n    template <typename T>\n    T mtrand(T a, T b) { // [a, b)\n        std::uniform_int_distribution<T> dist(a, b - 1);\n        return dist(rng);\n    }\n    double mtrand(double a, double b) { // [a, b]\n        std::uniform_real_distribution<double> dist(a, b);\n        return dist(rng);\n    }\n    long double mtrand(long double a, long double b) { // [a, b]\n        std::uniform_real_distribution<long double> dist(a, b);\n        return dist(rng);\n    }\n};\n// std::chrono::steady_clock::now().time_since_epoch().count()\n// uniform_int_distribution的构造依赖随机数生成器gen，gen.min()和gen.max()提供其范围\n// uniform_int_distribution将[gen.min(), gen.max()]映射到指定范围"
        ],
        "description": "math -> random.cpp snippet"
    },
    "math_unique_decomposition": {
        "prefix": "math_unique_decomposition",
        "body": [
            "const int N = (int) 1e7 + 5;\nint cntp = 0;\nvector<int> pri, pri_ord(N, 0), min_factor(N, 0);\nbool not_prime[N];\nvoid init() {\n    for (int i = 2; i < N; ++i) {\n        if (!not_prime[i]) {\n            pri.push_back(i);\n            pri_ord[i] = cntp++;\n            min_factor[i] = i;\n        }\n        for (int pri_j : pri) {\n            if (i * pri_j >= N) break;\n            not_prime[i * pri_j] = true;\n            min_factor[i * pri_j] = pri_j;\n            if (i % pri_j == 0) {\n                break;\n            }\n        }\n    }\n}\nmap<long long, int> decomp(int x) {\n    map<long long, int> mp;\n    while (x != 1) {\n        int mf = min_factor[x];\n        mp[mf]++;\n        x /= mf;\n    }\n    return mp;\n}\nmap<long long, int> decomp(long long x) {\n    map<long long, int> mp;\n    for (long long i = 2; i * i <= x; ++i) {\n        while (x % i == 0) {\n            mp[i]++;\n            x /= i;\n        }\n    }\n    if (x > 1) {\n        mp[x]++;\n    }\n    return mp;\n}\nint main() {\n    init();\n    for (int i = 1; i < 10000; ++i) {\n        assert(decomp(i) == decomp((long long) i));\n    }\n    cout << \"OK\" << '\\\\n';\n    return 0;\n}"
        ],
        "description": "math -> unique_decomposition.cpp snippet"
    },
    "poly_fft": {
        "prefix": "poly_fft",
        "body": [
            "template <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template <typename U>\n    Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template <typename U>\n    Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(int) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(int) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n            \"divl %4; \\\\n\\\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n            );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &\n    operator*=(const Modular &rhs) {\n        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    friend const Type &abs(const Modular &x) { return x.value; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template <typename V, typename U>\n    friend V &operator>>(V &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate <typename T>\nbool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U>\nbool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T>\nbool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate <typename T>\nbool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T>\nModular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T>\nModular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T>\nModular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T>\nModular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T> &number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU &operator<<(U &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU &operator>>(U &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, long long>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n \nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\n// make it understandable one day...\nnamespace fft {\n\n    typedef double dbl;\n\n    struct num {\n        dbl x, y;\n        num() { x = y = 0; }\n        num(dbl x_, dbl y_) : x(x_), y(y_) {}\n    };\n\n    inline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\n    inline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\n    inline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\n    inline num conj(num a) { return num(a.x, -a.y); }\n\n    int base = 1;\n    vector<num> roots = {{0, 0},\n                         {1, 0}};\n    vector<int> rev = {0, 1};\n\n    const dbl PI = static_cast<dbl>(acosl(-1.0));\n\n    void ensure_base(int nbase) {\n        if (nbase <= base) {\n            return;\n        }\n        rev.resize(1 << nbase);\n        for (int i = 0; i < (1 << nbase); i++) {\n            rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n        }\n        roots.resize(1 << nbase);\n        while (base < nbase) {\n            dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n            for (int i = 1 << (base - 1); i < (1 << base); i++) {\n                roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n                dbl angle_i = angle * (2 * i + 1 - (1 << base));\n                roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n            }\n            base++;\n        }\n    }\n\n    void fft(vector<num> &a, int n = -1) {\n        if (n == -1) {\n            n = (int) a.size();\n        }\n        assert((n & (n - 1)) == 0);\n        int zeros = __builtin_ctz(n);\n        ensure_base(zeros);\n        int shift = base - zeros;\n        for (int i = 0; i < n; i++) {\n            if (i < (rev[i] >> shift)) {\n                swap(a[i], a[rev[i] >> shift]);\n            }\n        }\n        for (int k = 1; k < n; k <<= 1) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    num z = a[i + j + k] * roots[j + k];\n                    a[i + j + k] = a[i + j] - z;\n                    a[i + j] = a[i + j] + z;\n                }\n            }\n        }\n    }\n\n    vector<num> fa, fb;\n\n    vector<int64_t> square(const vector<int> &a) {\n        if (a.empty()) {\n            return {};\n        }\n        int need = (int) a.size() + (int) a.size() - 1;\n        int nbase = 1;\n        while ((1 << nbase) < need) nbase++;\n        ensure_base(nbase);\n        int sz = 1 << nbase;\n        if ((sz >> 1) > (int) fa.size()) {\n            fa.resize(sz >> 1);\n        }\n        for (int i = 0; i < (sz >> 1); i++) {\n            int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n            int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n            fa[i] = num(x, y);\n        }\n        fft(fa, sz >> 1);\n        num r(1.0 / (sz >> 1), 0.0);\n        for (int i = 0; i <= (sz >> 2); i++) {\n            int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n            num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n            num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n            num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n            num tmp = fe * fo;\n            fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n            fa[j] = r * (aux + num(0, 2) * tmp);\n        }\n        fft(fa, sz >> 1);\n        vector<int64_t> res(need);\n        for (int i = 0; i < need; i++) {\n            res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n        }\n        return res;\n    }\n\n    vector<int64_t> multiply(const vector<int> &a, const vector<int> &b) {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        if (a == b) {\n            return square(a);\n        }\n        int need = (int) a.size() + (int) b.size() - 1;\n        int nbase = 1;\n        while ((1 << nbase) < need) nbase++;\n        ensure_base(nbase);\n        int sz = 1 << nbase;\n        if (sz > (int) fa.size()) {\n            fa.resize(sz);\n        }\n        for (int i = 0; i < sz; i++) {\n            int x = (i < (int) a.size() ? a[i] : 0);\n            int y = (i < (int) b.size() ? b[i] : 0);\n            fa[i] = num(x, y);\n        }\n        fft(fa, sz);\n        num r(0, -0.25 / (sz >> 1));\n        for (int i = 0; i <= (sz >> 1); i++) {\n            int j = (sz - i) & (sz - 1);\n            num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n            fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n            fa[i] = z;\n        }\n        for (int i = 0; i < (sz >> 1); i++) {\n            num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n            num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n            fa[i] = A0 + A1 * num(0, 1);\n        }\n        fft(fa, sz >> 1);\n        vector<int64_t> res(need);\n        for (int i = 0; i < need; i++) {\n            res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n        }\n        return res;\n    }\n\n    vector<int> multiply_mod(const vector<int> &a, const vector<int> &b, int m) {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        int eq = (a.size() == b.size() && a == b);\n        int need = (int) a.size() + (int) b.size() - 1;\n        int nbase = 0;\n        while ((1 << nbase) < need) nbase++;\n        ensure_base(nbase);\n        int sz = 1 << nbase;\n        if (sz > (int) fa.size()) {\n            fa.resize(sz);\n        }\n        for (int i = 0; i < (int) a.size(); i++) {\n            int x = (a[i] % m + m) % m;\n            fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n        }\n        fill(fa.begin() + a.size(), fa.begin() + sz, num{0, 0});\n        fft(fa, sz);\n        if (sz > (int) fb.size()) {\n            fb.resize(sz);\n        }\n        if (eq) {\n            copy(fa.begin(), fa.begin() + sz, fb.begin());\n        } else {\n            for (int i = 0; i < (int) b.size(); i++) {\n                int x = (b[i] % m + m) % m;\n                fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n            }\n            fill(fb.begin() + b.size(), fb.begin() + sz, num{0, 0});\n            fft(fb, sz);\n        }\n        dbl ratio = 0.25 / sz;\n        num r2(0, -1);\n        num r3(ratio, 0);\n        num r4(0, -ratio);\n        num r5(0, 1);\n        for (int i = 0; i <= (sz >> 1); i++) {\n            int j = (sz - i) & (sz - 1);\n            num a1 = (fa[i] + conj(fa[j]));\n            num a2 = (fa[i] - conj(fa[j])) * r2;\n            num b1 = (fb[i] + conj(fb[j])) * r3;\n            num b2 = (fb[i] - conj(fb[j])) * r4;\n            if (i != j) {\n                num c1 = (fa[j] + conj(fa[i]));\n                num c2 = (fa[j] - conj(fa[i])) * r2;\n                num d1 = (fb[j] + conj(fb[i])) * r3;\n                num d2 = (fb[j] - conj(fb[i])) * r4;\n                fa[i] = c1 * d1 + c2 * d2 * r5;\n                fb[i] = c1 * d2 + c2 * d1;\n            }\n            fa[j] = a1 * b1 + a2 * b2 * r5;\n            fb[j] = a1 * b2 + a2 * b1;\n        }\n        fft(fa, sz);\n        fft(fb, sz);\n        vector<int> res(need);\n        for (int i = 0; i < need; i++) {\n            int64_t aa = llround(fa[i].x);\n            int64_t bb = llround(fb[i].x);\n            int64_t cc = llround(fa[i].y);\n            res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);\n        }\n        return res;\n    }\n\n}  // namespace fft\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type operator*(\n    const vector<Modular<T>> &a,\n    const vector<Modular<T>> &b) {\n    if (a.empty() || b.empty()) {\n        return {};\n    }\n    if (min(a.size(), b.size()) < 150) {\n        vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n        for (int i = 0; i < (int) a.size(); i++) {\n            for (int j = 0; j < (int) b.size(); j++) {\n                c[i + j] += a[i] * b[j];\n            }\n        }\n        return c;\n    }\n    vector<int> a_mul(a.size());\n    for (int i = 0; i < (int) a.size(); i++) {\n        a_mul[i] = static_cast<int>(a[i]);\n    }\n    vector<int> b_mul(b.size());\n    for (int i = 0; i < (int) b.size(); i++) {\n        b_mul[i] = static_cast<int>(b[i]);\n    }\n    vector<int> c_mul = fft::multiply_mod(a_mul, b_mul, T::value);\n    vector<Modular<T>> c(c_mul.size());\n    for (int i = 0; i < (int) c.size(); i++) {\n        c[i] = c_mul[i];\n    }\n    return c;\n}\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type &operator*=(\n    vector<Modular<T>> &a,\n    const vector<Modular<T>> &b) {\n    return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> &operator+=(vector<T> &a, const vector<T> &b) {\n    if (a.size() < b.size()) {\n        a.resize(b.size());\n    }\n    for (int i = 0; i < (int) b.size(); i++) {\n        a[i] += b[i];\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T> &a, const vector<T> &b) {\n    vector<T> c = a;\n    return c += b;\n}\n\ntemplate <typename T>\nvector<T> &operator-=(vector<T> &a, const vector<T> &b) {\n    if (a.size() < b.size()) {\n        a.resize(b.size());\n    }\n    for (int i = 0; i < (int) b.size(); i++) {\n        a[i] -= b[i];\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T> &a, const vector<T> &b) {\n    vector<T> c = a;\n    return c -= b;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T> &a) {\n    vector<T> c = a;\n    for (int i = 0; i < (int) c.size(); i++) {\n        c[i] = -c[i];\n    }\n    return c;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T> &a, const vector<T> &b) {\n    if (a.empty() || b.empty()) {\n        return {};\n    }\n    vector<T> c(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) a.size(); i++) {\n        for (int j = 0; j < (int) b.size(); j++) {\n            c[i + j] += a[i] * b[j];\n        }\n    }\n    return c;\n}\n\ntemplate <typename T>\nvector<T> &operator*=(vector<T> &a, const vector<T> &b) {\n    return a = a * b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T> &a) {\n    assert(!a.empty());\n    int n = (int) a.size();\n    vector<T> b = {1 / a[0]};\n    while ((int) b.size() < n) {\n        vector<T> a_cut(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n        vector<T> x = b * b * a_cut;\n        b.resize(b.size() << 1);\n        for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n            b[i] = -x[i];\n        }\n    }\n    b.resize(n);\n    return b;\n}\n\ntemplate <typename T>\nvector<T> &operator/=(vector<T> &a, const vector<T> &b) {\n    int n = (int) a.size();\n    int m = (int) b.size();\n    if (n < m) {\n        a.clear();\n    } else {\n        vector<T> d = b;\n        reverse(a.begin(), a.end());\n        reverse(d.begin(), d.end());\n        d.resize(n - m + 1);\n        a *= inverse(d);\n        a.erase(a.begin() + n - m + 1, a.end());\n        reverse(a.begin(), a.end());\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T> &a, const vector<T> &b) {\n    vector<T> c = a;\n    return c /= b;\n}\n\ntemplate <typename T>\nvector<T> &operator%=(vector<T> &a, const vector<T> &b) {\n    int n = (int) a.size();\n    int m = (int) b.size();\n    if (n >= m) {\n        vector<T> c = (a / b) * b;\n        a.resize(m - 1);\n        for (int i = 0; i < m - 1; i++) {\n            a[i] -= c[i];\n        }\n    }\n    return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T> &a, const vector<T> &b) {\n    vector<T> c = a;\n    return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T> &a, const U &b, const vector<T> &c) {\n    assert(b >= 0);\n    vector<U> binary;\n    U bb = b;\n    while (bb > 0) {\n        binary.push_back(bb & 1);\n        bb >>= 1;\n    }\n    vector<T> res = vector<T>{1} % c;\n    for (int j = (int) binary.size() - 1; j >= 0; j--) {\n        res = res * res % c;\n        if (binary[j] == 1) {\n            res = res * a % c;\n        }\n    }\n    return res;\n}\n\ntemplate <typename T>\nvector<T> BM(vector<T> a) {\n    vector<T> p = {1};\n    vector<T> q = {1};\n    int l = 0;\n    for (int r = 1; r <= (int) a.size(); r++) {\n        T delta = 0;\n        for (int j = 0; j <= l; j++) {\n            delta += a[r - 1 - j] * p[j];\n        }\n        q.insert(q.begin(), 0);\n        if (delta != 0) {\n            vector<T> t = p;\n            if (q.size() > t.size()) {\n                t.resize(q.size());\n            }\n            for (int i = 0; i < (int) q.size(); i++) {\n                t[i] -= delta * q[i];\n            }\n            if (2 * l <= r - 1) {\n                q = p;\n                T od = 1 / delta;\n                for (T &x: q) {\n                    x *= od;\n                }\n                l = r - l;\n            }\n            swap(p, t);\n        }\n    }\n    assert((int) p.size() == l + 1);\n//  assert(l * 2 + 30 < (int) a.size());\n    reverse(p.begin(), p.end());\n    return p;\n}"
        ],
        "description": "poly -> fft.cpp snippet"
    },
    "poly_fft_rujialiu": {
        "prefix": "poly_fft_rujialiu",
        "body": [
            "\n\n// Rujia Liu\nconst long double PI = acos(0.0) * 2.0;\ntypedef complex<double> CD;\n// Cooley-Tukey的FFT算法，迭代实现。inverse = false时计算逆FFT\ninline void FFT(vector <CD> &a, bool inverse) {\n    int n = a.size();\n    // 原地快速bit reversal\n    for (int i = 0, j = 0; i < n; i++) {\n        if (j > i)\n            swap(a[i], a[j]);\n        int k = n;\n        while (j & (k >>= 1))\n            j &= ~k;\n        j |= k;\n    }\n    double pi = inverse ? -PI : PI;\n    for (int step = 1; step < n; step <<= 1) {\n        // 把每相邻两个“step点DFT”通过一系列蝴蝶操作合并为一个“2*step点DFT”\n        double alpha = pi / step;\n        // 为求高效，我们并不是依次执行各个完整的DFT合并，而是枚举下标k\n        // 对于一个下标k，执行所有DFT合并中该下标对应的蝴蝶操作，即通过E[k]和O[k]计算X[k]\n        // 蝴蝶操作参考：http://en.wikipedia.org/wiki/Butterfly_diagram\n        for (int k = 0; k < step; k++) {\n            // 计算omega^k.\n            // 这个方法效率低，但如果用每次乘omega的方法递推会有精度问题。\n            // 有更快更精确的递推方法，为了清晰起见这里略去\n            CD omegak = exp(CD(0, alpha * k));\n            for (int Ek = k; Ek < n;\n                 Ek += step << 1) {     // Ek是某次DFT合并中E[k]在原始序列中的下标\n                int Ok = Ek + step;     // Ok是该DFT合并中O[k]在原始序列中的下标\n                CD t = omegak * a[Ok];    // 蝴蝶操作：x1 * omega^k\n                a[Ok] = a[Ek] - t;        // 蝴蝶操作：y1 = x0 - t\n                a[Ek] += t;                // 蝴蝶操作：y0 = x0 + t\n            }\n        }\n    }\n\n    if (inverse)\n        for (int i = 0; i < n; i++)\n            a[i] /= n;\n}\n// 用FFT实现的快速多项式乘法\ninline vector<double> operator*(const vector<double> &v1,\n                                const vector<double> &v2) {\n    int s1 = v1.size(), s2 = v2.size(), S = 2;\n    while (S < s1 + s2)\n        S <<= 1;\n    vector <CD> a(S, 0),\n        b(S, 0);  // 把FFT的输入长度补成2的幂，不小于v1和v2的长度之和\n    for (int i = 0; i < s1; i++)\n        a[i] = v1[i];\n    FFT(a, false);\n    for (int i = 0; i < s2; i++)\n        b[i] = v2[i];\n    FFT(b, false);\n    for (int i = 0; i < S; i++)\n        a[i] *= b[i];\n    FFT(a, true);\n    vector<double> res(s1 + s2 - 1);\n    for (int i = 0; i < s1 + s2 - 1; i++)\n        res[i] = a[i].real();  // 虚部均为0\n    return res;\n}\n"
        ],
        "description": "poly -> fft_rujialiu.cpp snippet"
    },
    "poly_ntt": {
        "prefix": "poly_ntt",
        "body": [
            "\n#define N 1000005\n#define g 3//模数的原根\n#define mod 998244353//通常情况下的模数\nint pow(int x, int y) {\n    ll z = 1ll * x, ans = 1ll;\n    for (; y; y >>= 1, z = z * z % mod) {\n        if (y & 1) {\n            ans = ans * z % mod;\n        }\n    }\n    return (int) ans % mod;\n}\nint rev[N];\ninline void ntt(int a[], int len, int inv) {\n    int bit = 0;\n    while ((1 << bit) < len)++bit;\n    fk (i, 0, len) {\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));\n        if (i < rev[i]) {\n            swap(a[i], a[rev[i]]);\n        }\n    }\n    for (int mid = 1; mid < len; mid <<= 1) {\n        int tmp = pow(g, (mod - 1) / (mid * 2));\n        if (inv == -1) {\n            tmp = pow(tmp, mod - 2);\n        }\n        for (int i = 0; i < len; i += mid << 1) {\n            int omega = 1;\n            for (ll j = 0; j < mid; ++j, omega = 1ll * omega * tmp % mod) {\n                int x = a[i + j];\n                int y = omega * 1ll * a[i + j + mid] % mod;\n                a[i + j] = (x + y) % mod;\n                a[i + j + mid] = (x - y + mod) % mod;\n            }\n        }\n    }\n    if (inv == -1) {\n        int ni = pow(len, mod - 2);\n        for (int i = 0; i < len; ++i) {\n            a[i] = a[i] * 1ll * ni % mod;\n        }\n    }\n}\nconst int n = 4;\nint main() {\n    int a[] = {7, 9, 0, 0};\n    int b[] = {9, 3, 0, 0};\n    int c[n];\n    ntt(a, n, 1);\n    ntt(b, n, 1);\n    fk (i, 0, n) {\n        c[i] = a[i] * 1ll * b[i] % mod;\n    }\n    ntt(c, n, -1);\n    debug(vi(c, c + 4));\n}"
        ],
        "description": "poly -> ntt.cpp snippet"
    },
    "poly_ntt_tourist": {
        "prefix": "poly_ntt_tourist",
        "body": [
            "template<typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U>\n    Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U>\n    Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(int) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(int) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n            \"divl %4; \\\\n\\\\t\"\n            : \"=a\" (d), \"=d\" (m)\n            : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n            );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &\n    operator*=(const Modular &rhs) {\n        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    friend const Type &abs(const Modular &x) { return x.value; }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename V, typename U>\n    friend V &operator>>(V &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T>\nbool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U>\nbool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U>\nbool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T>\nbool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U>\nbool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U>\nbool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T>\nbool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T>\nModular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U>\nModular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T>\nModular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U>\nModular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T>\nModular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U>\nModular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T>\nModular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U>\nModular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate<typename T>\nbool IsZero(const Modular<T> &number) {\n    return number() == 0;\n}\n\ntemplate<typename T>\nstring to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate<typename U, typename T>\nU &operator<<(U &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate<typename U, typename T>\nU &operator>>(U &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, long long>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.push_back(fact.back() * (int) fact.size());\n        inv_fact.push_back(1 / fact.back());\n    }\n    return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\ntemplate<typename T>\nclass NTT {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    static Type md;\n    static Modular<T> root;\n    static int base;\n    static int max_base;\n    static vector<Modular<T>> roots;\n    static vector<int> rev;\n\n    static void clear() {\n        root = 0;\n        base = 0;\n        max_base = 0;\n        roots.clear();\n        rev.clear();\n    }\n\n    static void init() {\n        md = T::value;\n        assert(md >= 3 && md % 2 == 1);\n        auto tmp = md - 1;\n        max_base = 0;\n        while (tmp % 2 == 0) {\n            tmp /= 2;\n            max_base++;\n        }\n        root = 2;\n        while (power(root, (md - 1) >> 1) == 1) {\n            root++;\n        }\n        assert(power(root, md - 1) == 1);\n        root = power(root, (md - 1) >> max_base);\n        base = 1;\n        rev = {0, 1};\n        roots = {0, 1};\n    }\n\n    static void ensure_base(int nbase) {\n        if (md != T::value) {\n            clear();\n        }\n        if (roots.empty()) {\n            init();\n        }\n        if (nbase <= base) {\n            return;\n        }\n        assert(nbase <= max_base);\n        rev.resize(1 << nbase);\n        for (int i = 0; i < (1 << nbase); i++) {\n            rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n        }\n        roots.resize(1 << nbase);\n        while (base < nbase) {\n            Modular<T> z = power(root, 1 << (max_base - 1 - base));\n            for (int i = 1 << (base - 1); i < (1 << base); i++) {\n                roots[i << 1] = roots[i];\n                roots[(i << 1) + 1] = roots[i] * z;\n            }\n            base++;\n        }\n    }\n\n    static void fft(vector<Modular<T>> &a) {\n        int n = (int) a.size();\n        assert((n & (n - 1)) == 0);\n        int zeros = __builtin_ctz(n);\n        ensure_base(zeros);\n        int shift = base - zeros;\n        for (int i = 0; i < n; i++) {\n            if (i < (rev[i] >> shift)) {\n                swap(a[i], a[rev[i] >> shift]);\n            }\n        }\n        for (int k = 1; k < n; k <<= 1) {\n            for (int i = 0; i < n; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    Modular<T> x = a[i + j];\n                    Modular<T> y = a[i + j + k] * roots[j + k];\n                    a[i + j] = x + y;\n                    a[i + j + k] = x - y;\n                }\n            }\n        }\n    }\n\n    static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        int eq = (a == b);\n        int need = (int) a.size() + (int) b.size() - 1;\n        int nbase = 0;\n        while ((1 << nbase) < need) nbase++;\n        ensure_base(nbase);\n        int sz = 1 << nbase;\n        a.resize(sz);\n        b.resize(sz);\n        fft(a);\n        if (eq) b = a; else fft(b);\n        Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n        for (int i = 0; i < sz; i++) {\n            a[i] *= b[i] * inv_sz;\n        }\n        reverse(a.begin() + 1, a.end());\n        fft(a);\n        a.resize(need);\n        return a;\n    }\n};\n\ntemplate<typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate<typename T> Modular<T> NTT<T>::root;\ntemplate<typename T> int NTT<T>::base;\ntemplate<typename T> int NTT<T>::max_base;\ntemplate<typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate<typename T> vector<int> NTT<T>::rev;\n\ntemplate<typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>> &a) {\n    assert(!a.empty());\n    int n = (int) a.size();\n    vector<Modular<T>> b = {1 / a[0]};\n    while ((int) b.size() < n) {\n        vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n        x.resize(b.size() << 1);\n        b.resize(b.size() << 1);\n        vector<Modular<T>> c = b;\n        NTT<T>::fft(c);\n        NTT<T>::fft(x);\n        Modular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n        for (int i = 0; i < (int) x.size(); i++) {\n            x[i] *= c[i] * inv;\n        }\n        reverse(x.begin() + 1, x.end());\n        NTT<T>::fft(x);\n        rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n        fill(x.begin() + (x.size() >> 1), x.end(), 0);\n        NTT<T>::fft(x);\n        for (int i = 0; i < (int) x.size(); i++) {\n            x[i] *= c[i] * inv;\n        }\n        reverse(x.begin() + 1, x.end());\n        NTT<T>::fft(x);\n        for (int i = 0; i < ((int) x.size() >> 1); i++) {\n            b[i + ((int) x.size() >> 1)] = -x[i];\n        }\n    }\n    b.resize(n);\n    return b;\n}\n\ntemplate<typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n    assert(!a.empty());\n    int n = (int) a.size();\n    if (n == 1) {\n        return {1 / a[0]};\n    }\n    int m = (n + 1) >> 1;\n    vector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n    int need = n << 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) {\n        ++nbase;\n    }\n    NTT<T>::ensure_base(nbase);\n    int size = 1 << nbase;\n    a.resize(size);\n    b.resize(size);\n    NTT<T>::fft(a);\n    NTT<T>::fft(b);\n    Modular<T> inv = 1 / static_cast<Modular<T>>(size);\n    for (int i = 0; i < size; ++i) {\n        a[i] = (2 - a[i] * b[i]) * b[i] * inv;\n    }\n    reverse(a.begin() + 1, a.end());\n    NTT<T>::fft(a);\n    a.resize(n);\n    return a;\n}\n\ntemplate<typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>> &a, const vector<Modular<T>> &b) {\n    if (a.empty() || b.empty()) {\n        return {};\n    }\n    if (min(a.size(), b.size()) < 150) {\n        vector<Modular<T>> c(a.size() + b.size() - 1, 0);\n        for (int i = 0; i < (int) a.size(); i++) {\n            for (int j = 0; j < (int) b.size(); j++) {\n                c[i + j] += a[i] * b[j];\n            }\n        }\n        return c;\n    }\n    return NTT<T>::multiply(a, b);\n}\n\ntemplate<typename T>\nvector<Modular<T>> &operator*=(vector<Modular<T>> &a, const vector<Modular<T>> &b) {\n    return a = a * b;\n}"
        ],
        "description": "poly -> ntt_tourist.cpp snippet"
    },
    "string_suffix_array": {
        "prefix": "string_suffix_array",
        "body": [
            "template <typename T>\nvector<int> suffix_array(int n, const T &s, int char_bound) {\n    vector<int> a(n);\n    if (n == 0) {\n        return a;\n    }\n    if (char_bound != -1) {\n        vector<int> aux(char_bound, 0);\n        for (int i = 0; i < n; i++) {\n            aux[s[i]]++;\n        }\n        int sum = 0;\n        for (int i = 0; i < char_bound; i++) {\n            int add = aux[i];\n            aux[i] = sum;\n            sum += add;\n        }\n        for (int i = 0; i < n; i++) {\n            a[aux[s[i]]++] = i;\n        }\n    } else {\n        iota(a.begin(), a.end(), 0);\n        sort(a.begin(), a.end(), [&s](int i, int j) {\n            return s[i] < s[j];\n        });\n    }\n    vector<int> sorted_by_second(n);\n    vector<int> ptr_group(n);\n    vector<int> new_group(n);\n    vector<int> group(n);\n    group[a[0]] = 0;\n    for (int i = 1; i < n; i++) {\n        group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\n    }\n    int cnt = group[a[n - 1]] + 1;\n    int step = 1;\n    while (cnt < n) {\n        int at = 0;\n        for (int i = n - step; i < n; i++) {\n            sorted_by_second[at++] = i;\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] - step >= 0) {\n                sorted_by_second[at++] = a[i] - step;\n            }\n        }\n        // a 是 step = pre的sort index\n        // sbs 是 step = cur的sort index\n        // group 是 上一每个桶内的计数\n        for (int i = n - 1; i >= 0; i--) {\n            ptr_group[group[a[i]]] = i;\n        }\n        // ptr_group是每个桶的起始编号\n        for (int i = 0; i < n; i++) {\n            int x = sorted_by_second[i]; // x比它同桶内的其他，更先获得编号\n            a[ptr_group[group[x]]++] = x;\n        }\n        new_group[a[0]] = 0;\n        for (int i = 1; i < n; i++) { // a已经排好序，new_group是新桶\n            if (group[a[i]] != group[a[i - 1]]) {\n                new_group[a[i]] = new_group[a[i - 1]] + 1;\n            } else {\n                int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\n                int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\n                new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\n            }\n        }\n        swap(group, new_group);\n        cnt = group[a[n - 1]] + 1;\n        step <<= 1;\n    }\n    return a;\n}\ntemplate <typename T>\nvector<int> suffix_array(const T &s, int char_bound) {\n    return suffix_array((int)s.size(), s, char_bound);\n}\ntemplate <typename T>\nvector<int> build_lcp(int n, const T &s, const vector<int> &sa) {\n    assert((int)sa.size() == n);\n    vector<int> pos(n);\n    for (int i = 0; i < n; i++) {\n        pos[sa[i]] = i;\n    }\n    vector<int> lcp(max(n - 1, 0));\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        k = max(k - 1, 0);\n        if (pos[i] == n - 1) {\n            k = 0;\n        } else {\n            int j = sa[pos[i] + 1];\n            while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n                k++;\n            }\n            lcp[pos[i]] = k;\n        }\n    }\n    return lcp;\n}\ntemplate <typename T>\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\n    return build_lcp((int)s.size(), s, sa);\n}\n"
        ],
        "description": "string -> suffix_array.cpp snippet"
    },
    "string_zalgorithm_is_substring": {
        "prefix": "string_zalgorithm_is_substring",
        "body": [
            "template <typename S>\nvector<int> zalgorithm(const S &s) {  // zalgo: [i, ...]与 [0, ...]的前缀匹配长度\n    int n = int(s.size());\n    if (n == 0) return {};\n    vector<int> z(n);\n    z[0] = 0;\n    for (int i = 1, j = 0; i < n; i++) {\n        int &k = z[i];\n        k = (j + z[j] <= i) ? 0 : min(j + z[j] - i, z[i - j]);\n        while (i + k < n && s[k] == s[i + k]) k++;\n        if (j + z[j] < i + z[i]) j = i;\n    }\n    z[0] = n;\n    return z;\n}\ntemplate <typename S>\nbool is_substring(S &s, S &t) {  // zalgo: is_substring\n    int n = int(s.size()), m = int(t.size());\n    S st;\n    for (auto &&x : s) st.push_back(x);\n    for (auto &&x : t) st.push_back(x);\n    auto Z = zalgorithm(st);\n    for (int i = n; i < n + m; ++i) {\n        if (Z[i] >= n) return true;\n    }\n    return false;\n}"
        ],
        "description": "string -> zalgorithm_is_substring.cpp snippet"
    },
    "za_linear_basis_xianxingji": {
        "prefix": "za_linear_basis_xianxingji",
        "body": [
            "int64_t p[64];\n\nvoid insert(ull x) {\n    for (int i = 63; ~i; --i) {\n        if (!(x >> i))  // x 的第 i 位是 0\n            continue;\n        if (!p[i]) {\n            p[i] = x;\n            break;\n        }\n        x ^= p[i];\n    }\n}"
        ],
        "description": "za -> linear_basis_xianxingji.cpp snippet"
    }
}